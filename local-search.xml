<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>js一些语法小技巧</title>
    <link href="/2021/10/27/js%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/10/27/js%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>有空还是得看看大佬写的代码，有的语法和小技巧可以借鉴一下，确实能提高不少效率。</p><h2 id="1-js双叹号的作用"><a href="#1-js双叹号的作用" class="headerlink" title="1.js双叹号的作用"></a>1.js双叹号的作用</h2><p>按照我的理解，就是为一些基础数据类型做一下Boolean类型的返回，比如<code>（null/undifined/0/&quot;&quot;/NaN）</code>等值，可以返回false</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">var unknow = null; <span class="hljs-regexp">//</span> 这里可以是null<span class="hljs-regexp">/undifined/</span><span class="hljs-number">0</span><span class="hljs-regexp">/&quot;&quot;/</span>NaN任意的值<br>console.log(!!unknow); <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><h2 id="2-js可选链操作符"><a href="#2-js可选链操作符" class="headerlink" title="2.js可选链操作符"></a>2.js可选链操作符</h2><p>这段代码之前老是这么写</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">var</span> ret = res.<span class="hljs-class"><span class="hljs-keyword">data</span> &amp;&amp; res.<span class="hljs-keyword">data</span>.list;</span><br></code></pre></td></tr></table></figure><p>其实是可以这么写的</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">var <span class="hljs-keyword">ret</span> = res.data?<span class="hljs-meta">.list</span><br></code></pre></td></tr></table></figure><p>有点像链式调用，这里需要引申出来这么一个小问题，|| 和 ??的用法</p><h2 id="3-JS中-与-的区别"><a href="#3-JS中-与-的区别" class="headerlink" title="3. JS中??与||的区别"></a>3. JS中??与||的区别</h2><p>相同点：</p><blockquote><p>用法相同，都是前后是值，中间用符号连接。根据前面的值来判断最终返回前面的值还是后面的值。</p></blockquote><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">值<span class="hljs-number">1</span> ?? 值<span class="hljs-number">2</span><br>值<span class="hljs-number">1</span> <span class="hljs-string">|| 值2</span><br></code></pre></td></tr></table></figure><p>不同点:</p><blockquote><p>判断方式不同：</p></blockquote><ul><li>使用 <code>??</code> 时，只有当<code>值1</code>为<code>null</code>或<code>undefined</code>时才返回<code>值2</code>；</li><li>使用 <code>||</code> 时，<code>值1</code>会转换为布尔值判断，为<code>true</code>返回<code>值1</code>，false 返回<code>值2</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> ??<br>undefined ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>null ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-number">0</span> ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><span class="hljs-string">&quot;&quot;</span> ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br>true ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> true<br>false ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> false<br><br><span class="hljs-regexp">//</span> ||<br>undefined || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>null || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-number">0</span> || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-string">&quot;&quot;</span> || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>true || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> true<br>false || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><p>总的来说，<code>??</code>更加适合在不知道变量是否有值时使用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>农民工日记03</title>
    <link href="/2021/10/24/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B003/"/>
    <url>/2021/10/24/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B003/</url>
    
    <content type="html"><![CDATA[<h3 id="1-浏览器重绘和重排的区别？"><a href="#1-浏览器重绘和重排的区别？" class="headerlink" title="1.浏览器重绘和重排的区别？"></a>1.浏览器重绘和重排的区别？</h3><blockquote><p>如何触发重排和重绘？</p></blockquote><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><blockquote><p>如何避免重绘或者重排？</p></blockquote><ol><li><p>集中改变样式，不要一条一条地修改 DOM 的样式。</p></li><li><p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p></li><li><p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</p></li><li><p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p></li><li><p>尽量只修改position：absolute或fixed元素，对其他元素影响不大</p></li><li><p>动画开始GPU加速，translate使用3D变化</p></li><li><p>提升为合成层<br>将元素提升为合成层有以下优点：</p></li></ol><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p>提升合成层的最好方式是使用 CSS 的 will-change 属性：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">#<span class="hljs-keyword">target</span> &#123;<br>  will-<span class="hljs-built_in">change</span>: transform;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-手写常见排序"><a href="#2-手写常见排序" class="headerlink" title="2. 手写常见排序"></a>2. 手写常见排序</h3><ul><li>冒泡排序</li></ul><blockquote><p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 <code>length - 1</code> 的位置。</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(list)</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> n = list.length;<br>  <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> [];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-comment">// 注意这里需要 n - i - 1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (list[j] &gt; list[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">var</span> temp = list[j + <span class="hljs-number">1</span>];<br>        list[j + <span class="hljs-number">1</span>] = list[j];<br>        list[j] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>快速排序</li></ul><blockquote><p>快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel">function quickSort(list) &#123;<br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">n</span> = list.length;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">1</span>) return list;<br><br>  <span class="hljs-built_in">var</span> midIndex = Math.floor(<span class="hljs-built_in">n</span> / <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">var</span> midVal = list[midIndex]; // 取中间的数<br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">left</span> = [];<br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">right</span> = [];<br><br>  for (<span class="hljs-built_in">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++) &#123;<br>    <span class="hljs-built_in">if</span> (i === midIndex) continue;<br>    <span class="hljs-built_in">if</span> (list[i] &lt; midVal) &#123;<br>      left.push(list[i]);<br>    &#125; else &#123;<br>      right.push(list[i]);<br>    &#125;<br>  &#125;<br><br>  // 递归<br>  return quickSort(<span class="hljs-built_in">left</span>).<span class="hljs-built_in">concat</span>(quickSort(<span class="hljs-built_in">right</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-解决跨域问题"><a href="#3-解决跨域问题" class="headerlink" title="3. 解决跨域问题"></a>3. 解决跨域问题</h3><p>- </p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>农民工日记02</title>
    <link href="/2021/10/13/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B002/"/>
    <url>/2021/10/13/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B002/</url>
    
    <content type="html"><![CDATA[<h3 id="1-深拷贝，浅拷贝"><a href="#1-深拷贝，浅拷贝" class="headerlink" title="1.深拷贝，浅拷贝"></a>1.深拷贝，浅拷贝</h3><ul><li>浅拷贝：重新在堆中创建内存，拷贝前后对象的<code>基本数据类型互不影响</code>，但拷贝前后对象的<code>引用类型</code>因共享同一块内存，会<code>相互影响</code>。</li><li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。</li></ul><p>个人理解：重点是引用类型会相互影响</p><p>基础数据类型：Undefined、Null、Boolean、Number、String、Symbol<br>引用类型：统称为 <code>Object</code> 类型。细分的话，有：<code>Object</code> 类型、<code>Array</code> 类型、<code>Date</code> 类型、<code>RegExp</code> 类型、<code>Function</code> 类型</p><p>我们先来看下面的例子，对比赋值与深/浅拷贝得到的对象修改后对原始对象的影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象赋值</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;浪里行舟&#x27;</span>,<br>    <span class="hljs-attr">arr</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-number">4</span>],<br>&#125;;<br><span class="hljs-keyword">let</span> obj2 = obj1;<br>obj2.name = <span class="hljs-string">&quot;阿浪&quot;</span>;<br>obj2.arr[<span class="hljs-number">1</span>] =[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] ;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj1&#x27;</span>,obj1) <span class="hljs-comment">// obj1 &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj2&#x27;</span>,obj2) <span class="hljs-comment">// obj2 &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="hljs-comment">// 浅拷贝</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;浪里行舟&#x27;</span>,<br>    <span class="hljs-attr">arr</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-number">4</span>],<br>&#125;;<br><span class="hljs-keyword">let</span> obj3=shallowClone(obj1)<br>obj3.name = <span class="hljs-string">&quot;阿浪&quot;</span>;<br>obj3.arr[<span class="hljs-number">1</span>] = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] ; <span class="hljs-comment">// 新旧对象还是共享同一块内存</span><br><span class="hljs-comment">// 这是个浅拷贝的方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowClone</span>(<span class="hljs-params">source</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> target = &#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> source) &#123;<br>        <span class="hljs-keyword">if</span> (source.hasOwnProperty(i)) &#123;<br>            target[i] = source[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj1&#x27;</span>,obj1) <span class="hljs-comment">// obj1 &#123; name: &#x27;浪里行舟&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj3&#x27;</span>,obj3) <span class="hljs-comment">// obj3 &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="hljs-comment">// 深拷贝</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;浪里行舟&#x27;</span>,<br>    <span class="hljs-attr">arr</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-number">4</span>],<br>&#125;;<br><span class="hljs-keyword">let</span> obj4=deepClone(obj1)<br>obj4.name = <span class="hljs-string">&quot;阿浪&quot;</span>;<br>obj4.arr[<span class="hljs-number">1</span>] = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] ; <span class="hljs-comment">// 新对象跟原对象不共享内存</span><br><span class="hljs-comment">// 这是个深拷贝的方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj; <br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj);<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> obj;<br>    <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.constructor();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>      <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>        <span class="hljs-comment">// 实现一个递归拷贝</span><br>        cloneObj[key] = deepClone(obj[key]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneObj;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj1&#x27;</span>,obj1) <span class="hljs-comment">// obj1 &#123; name: &#x27;浪里行舟&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj4&#x27;</span>,obj4) <span class="hljs-comment">// obj4 &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br></code></pre></td></tr></table></figure><p>浅克隆实现方式：</p><ul><li>Object. assign();</li><li>函数库lodash的_.clone方法</li><li>Array.prototype.concat();</li><li>Array.prototype.slice();</li></ul><p>深拷贝的实现方式：</p><ul><li>JSON.parse(JSON.stringify()); <strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则</strong></li><li>函数库lodash的_.cloneDeep方法</li></ul><h3 id="2-bind，apply，call的区别"><a href="#2-bind，apply，call的区别" class="headerlink" title="2. bind，apply，call的区别"></a>2. bind，apply，call的区别</h3><p>　　三者都是用于改变函数体内this的指向，但是bind与apply和call的最大的区别是：bind不会立即调用，而是返回一个新函数，称为绑定函数，其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj);<br>&#125;<br><br>test(); <span class="hljs-comment">//false</span><br><br><span class="hljs-keyword">var</span> testObj = test.bind(obj);<br>testObj();  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><pre><code>apply和call都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）；apply和call的调用返回函数执行结果；</code></pre><p>　　如果使用apply或call方法，那么this指向他们的第一个参数，apply的第二个参数是一个参数数组，call的第二个及其以后的参数都是数组里面的元素，就是说要全部列举出来；</p><h3 id="3-从浏览器地址栏输入url到显示页面的步骤"><a href="#3-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="3. 从浏览器地址栏输入url到显示页面的步骤"></a>3. 从浏览器地址栏输入url到显示页面的步骤</h3><p><strong>基础版本</strong></p><ul><li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；（url域名解析，发送请求）</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML</code>、<code>JS</code>、<code>CSS</code>、图象等）；（后端处理请求，浏览器接受文件）</li><li>浏览器对加载到的资源（<code>HTML</code>、<code>JS</code>、<code>CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；（浏览器解析静态资源，建立数据结构）</li><li>载入解析到的资源文件，渲染页面，完成。（载入，渲染）</li></ul><h3 id="4-http和https的区别"><a href="#4-http和https的区别" class="headerlink" title="4. http和https的区别"></a>4. http和https的区别</h3><ul><li>安全性。HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>协议。使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>响应速度。HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>端口。http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>资源占用。HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul><h3 id="5-TCP三次握手"><a href="#5-TCP三次握手" class="headerlink" title="5. TCP三次握手"></a>5. TCP三次握手</h3><p>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认<br>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态<br>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p><h3 id="6-进程、线程、协程"><a href="#6-进程、线程、协程" class="headerlink" title="6. 进程、线程、协程"></a>6. 进程、线程、协程</h3><p><strong>进程</strong>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<code>是操作系统进行资源分配和调度的一个独立单位</code>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p><strong>线程</strong>是程序执行中一个单一的顺序控制流程，是<code>程序执行流的最小单元</code>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p><strong>协程</strong>，英文Coroutines，是一种<code>基于线程之上，但又比线程更加轻量级的存在</code>，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p><strong>进程和线程的区别与联系</strong></p><p>【区别】：<br>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</p><p>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p><p>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p><p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><p>【联系】：<br>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p><p>处理机分给线程，即真正在处理机上运行的是线程；</p><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步</p><h3 id="7-this的指向（5种情况）"><a href="#7-this的指向（5种情况）" class="headerlink" title="7. this的指向（5种情况）"></a>7. this的指向（5种情况）</h3><ol><li>作为普通函数执行时，<code>this</code>指向<code>window</code>。</li><li>当函数作为对象的方法被调用时，<code>this</code>就会指向<code>该对象</code>。</li><li>构造器调用，<code>this</code>指向<code>返回的这个对象</code>。 new出来的</li><li>箭头函数 箭头函数的<code>this</code>绑定看的是<code>this所在函数定义在哪个对象下</code>，就绑定哪个对象。如果有嵌套的情况，则this绑定到最近的一层对象上。</li><li>基于Function.prototype上的<code>apply 、 call 和 bind</code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，<code> bind</code>方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this指向除了使用new时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</li></ol><p>// 你不知道的js讲解(感觉这个更好理解一点)</p><ol><li><p>默认绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>run();  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p> 隐式绑定：就是我们常说的，谁调用就绑定谁</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">function <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">this</span>.a);<br>&#125;<br>var obj = &#123;<br>    a: <span class="hljs-number">1</span>,<br>    run<br>&#125;<br>obj.<span class="hljs-built_in">run</span>();  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p>显示绑定：call、apply、bind 实现的绑定我们称为实现显示绑定</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(param) &#123; <br>    console.log( param, this.id ); <br>&#125;<br>var obj = &#123; <br>    id: <span class="hljs-string">&quot;welcome&quot;</span><br>&#125;; <br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach( run, obj );  // <span class="hljs-number">1</span> <span class="hljs-string">&quot;welcome&quot;</span> <span class="hljs-number">2</span> <span class="hljs-string">&quot;welcome&quot;</span> <span class="hljs-number">3</span> <span class="hljs-string">&quot;welcome&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>new绑定</p></li></ol><p>new 就是一个可以调用普通函数的操作符，使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><p>创建（或者说构造）一个全新的对象。=&gt;</p><p>这个新对象会被执行 [[ 原型 ]] 连接。=&gt;</p><p>这个新对象会绑定到函数调用的 this。=&gt;</p><p>如果函数没有返回其他对象，那么 <strong>new 表达式中的函数调用会自动返回这个新对象</strong>。</p><ol start="5"><li>箭头函数下的this</li></ol><p>我们都知道箭头函数没有自己的 this，它的 this 来自于外层作用域，也因为箭头函数没有自己的 this 这一特性，它不能被用作构造函数。<br>箭头函数不使用上面  this  的四种标准规则，函数执行时，它会捕获外层作用域的  this ，一经绑定再也无法修改，并且高于 new 绑定。</p><ol start="6"><li>优先级</li></ol><p>（箭头函数下的this）=&gt; new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>农民工日记01</title>
    <link href="/2021/09/26/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B001/"/>
    <url>/2021/09/26/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>有些东西不写下来真的是记不住，看几次忘几次，真的佛了。。。</p><h3 id="1-dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点（描述浏览器的渲染过程，DOM树和渲染树的区别）"><a href="#1-dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点（描述浏览器的渲染过程，DOM树和渲染树的区别）" class="headerlink" title="1. dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点（描述浏览器的渲染过程，DOM树和渲染树的区别）"></a>1. dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点（描述浏览器的渲染过程，DOM树和渲染树的区别）</h3><ul><li><p>浏览器的渲染过程：</p><ul><li>解析<code>HTML</code>构建<code>DOM</code>(DOM树)，并行请求<code>css/image/js</code></li><li><code>CSS</code> 文件下载完成，开始构建 <code>CSSOM</code>(<code>CSS</code>树)</li><li><code>CSSOM</code> 构建结束后，和 <code>DOM</code> 一起生成 <code>Render Tree</code>(渲染树)</li><li>布局(<code>Layout</code>)：计算出每个节点在屏幕中的位置</li><li>显示(<code>Painting</code>)：通过显卡把页面画到屏幕上</li></ul></li><li><p><code>DOM</code>树 和 渲染树 的区别：</p><ul><li><code>DOM</code>树与<code>HTML</code>标签一一对应，包括<code>head</code>和隐藏元素</li><li>渲染树不包括<code>head</code>和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的<code>css</code>属性</li></ul></li></ul><h3 id="2-CSS会阻塞dom解析吗？"><a href="#2-CSS会阻塞dom解析吗？" class="headerlink" title="2. CSS会阻塞dom解析吗？"></a>2. CSS会阻塞dom解析吗？</h3><p>先说结论：</p><ul><li>css加载不会阻塞DOM树的解析</li><li>css加载会阻塞DOM树的渲染</li><li>css加载会阻塞后面js语句的执行</li></ul><p>因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:</p><ul><li>使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)</li><li>对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)</li><li>合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)</li><li>减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)</li></ul><p>个人对这种机制的评价<br>其实我觉得，这可能也是浏览器的一种优化机制。因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以我干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染DOM树，这种做法性能方面确实会比较好一点。</p><h3 id="3-浏览器的渲染过程"><a href="#3-浏览器的渲染过程" class="headerlink" title="3. 浏览器的渲染过程"></a>3. 浏览器的渲染过程</h3><p><a href="https://blog.poetries.top/FE-Interview-Questions/docs/excellent.html#_21-1-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">https://blog.poetries.top/FE-Interview-Questions/docs/excellent.html#_21-1-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B</a></p><ol><li>浏览器接收到<strong>HTML</strong>文件并转换为<strong>DOM</strong>树</li><li>将<strong>CSS</strong>文件转换为<strong>CSSOM</strong>树</li><li>生成渲染树</li></ol><h3 id="4-实现一个call（手写）"><a href="#4-实现一个call（手写）" class="headerlink" title="4. 实现一个call（手写）"></a>4. 实现一个call（手写）</h3><p>call做了什么:</p><ul><li>将函数设为对象的属性</li><li>执行&amp;删除这个函数</li><li>指定this到函数并传入给定参数执行函数</li><li>如果不传入参数，默认指向为 window<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs maxima">// 模拟 call bar.mycall(null);<br>//实现一个call方法：<br>// 原理：利用 <span class="hljs-built_in">context</span>.xxx = self obj.xx = func--&gt;obj.xx()<br>Function.prototype.myCall = function(<span class="hljs-built_in">context</span> = window, ...<span class="hljs-built_in">args</span>) &#123;<br>  // this--&gt;func  <span class="hljs-built_in">context</span>--&gt; obj  <span class="hljs-built_in">args</span>--&gt; 传递过来的参数<br><br>  // 在<span class="hljs-built_in">context</span>上加一个唯一值不影响<span class="hljs-built_in">context</span>上的属性<br>  <span class="hljs-built_in">let</span> <span class="hljs-built_in">key</span> = Symbol(&#x27;<span class="hljs-built_in">key</span>&#x27;)<br>  <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>] = this; // <span class="hljs-built_in">context</span>为调用的上下文,this此处为函数，将这个函数作为<span class="hljs-built_in">context</span>的方法<br>  // <span class="hljs-built_in">let</span> <span class="hljs-built_in">args</span> = [...arguments].slice(<span class="hljs-number">1</span>)   //第一个参数为obj所以删除,伪数组转为数组<br>  <br>  <span class="hljs-built_in">let</span> result = <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>](...<span class="hljs-built_in">args</span>);<br>  <span class="hljs-built_in">delete</span> <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>]; // 不删除会导致<span class="hljs-built_in">context</span>属性越来越多<br>  <span class="hljs-built_in">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//用法：f.call(obj,arg1)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(a+b)<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><span class="hljs-keyword">let</span> obj=&#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-number">1</span><br>&#125;<br>f.myCall(obj,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//否则this指向window</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-实现一个apply（手写）"><a href="#5-实现一个apply（手写）" class="headerlink" title="5. 实现一个apply（手写）"></a>5. 实现一个apply（手写）</h3><blockquote><p>思路: 利用<code>this</code>的上下文特性。</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Function.prototype.myApply = function(<span class="hljs-built_in">context</span> = window, ...<span class="hljs-built_in">args</span>) &#123;<br>  // this--&gt;func  <span class="hljs-built_in">context</span>--&gt; obj  <span class="hljs-built_in">args</span>--&gt; 传递过来的参数<br><br>  // 在<span class="hljs-built_in">context</span>上加一个唯一值不影响<span class="hljs-built_in">context</span>上的属性<br>  <span class="hljs-built_in">let</span> <span class="hljs-built_in">key</span> = Symbol(&#x27;<span class="hljs-built_in">key</span>&#x27;)<br>  <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>] = this; // <span class="hljs-built_in">context</span>为调用的上下文,this此处为函数，将这个函数作为<span class="hljs-built_in">context</span>的方法<br>  // <span class="hljs-built_in">let</span> <span class="hljs-built_in">args</span> = [...arguments].slice(<span class="hljs-number">1</span>)   //第一个参数为obj所以删除,伪数组转为数组<br>  <br>  <span class="hljs-built_in">let</span> result = <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>](<span class="hljs-built_in">args</span>); // 这里和call传参不一样<br>  <span class="hljs-built_in">delete</span> <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>]; // 不删除会导致<span class="hljs-built_in">context</span>属性越来越多<br>  <span class="hljs-built_in">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(a,b)<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><span class="hljs-keyword">let</span> obj=&#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span><br>&#125;<br>f.myApply(obj,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])  <span class="hljs-comment">//arguments[1]</span><br></code></pre></td></tr></table></figure><h3 id="6-实现bind"><a href="#6-实现bind" class="headerlink" title="6. 实现bind"></a>6. 实现bind</h3><blockquote><p>bind 的实现对比其他两个函数略微地复杂了一点，因为 bind 需要返回一个函数，需要判断一些边界问题，以下是 bind 的实现</p></blockquote><ul><li><code>bind</code> 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 <code>new</code> 的方式，我们先来说直接调用的方式<br>对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来<br>最后来说通过 new 的方式，对于 new 的情况来说，不会被任何方式改变 <code>this</code>，所以对于这种情况我们需要忽略传入的 <code>this</code></li></ul><p><strong>简洁版本</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Function.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(context, <span class="hljs-rest_arg">...outerArgs</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// this-&gt;func context-&gt;obj outerArgs-&gt;[10,20]</span><br>  let self = <span class="hljs-keyword">this</span><br><br>  <span class="hljs-comment">// 返回一个函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-rest_arg">...innerArgs</span>)</span> </span>&#123; <span class="hljs-comment">//返回了一个函数，...innerArgs为实际调用时传入的参数</span><br>    <span class="hljs-comment">// 考虑new的方式</span><br>    <span class="hljs-keyword">if</span>(self <span class="hljs-keyword">instanceof</span> F) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> self(...outerArgs, ...innerArgs)<br>    &#125;<br>    <span class="hljs-comment">// 把func执行，并且改变this即可</span><br>    <span class="hljs-keyword">return</span> self.apply(context, [...outerArgs, ...innerArgs]) <span class="hljs-comment">//返回改变了this的函数，参数合并</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 例子</span><br>document.body.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">func</span>.<span class="hljs-params">bind</span>(<span class="hljs-params">obj</span>, 10, 20)</span>)<br><br><span class="hljs-keyword">function</span> func(params) &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意： bind之后不能再次修改this的执行，bind多次后执行，函数this还是指向第一次bind的对象</p></blockquote><h3 id="7-防抖（手写）"><a href="#7-防抖（手写）" class="headerlink" title="7. 防抖（手写）"></a>7. 防抖（手写）</h3><blockquote><p>防抖函数原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时`</p></blockquote><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p><blockquote><p>eg. 像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><br><span class="hljs-comment">// wait是等待时间</span><br><span class="hljs-keyword">const</span> debounce = (func, wait = <span class="hljs-number">50</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 缓存一个定时器id</span><br>  let timer = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 这里返回的函数是每次用户实际调用的防抖函数</span><br>  <span class="hljs-comment">// 如果已经设定过定时器了就清空上一次的定时器</span><br>  <span class="hljs-comment">// 开始一个新的定时器，延迟执行用户传入的方法</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (timer) clearTimeout(timer)<br>    timer = setTimeout(() =&gt; &#123;<br>      func.apply(<span class="hljs-keyword">this</span>, args)<br>    &#125;, wait)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10个好用的的css框架</title>
    <link href="/2021/09/21/10%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84css%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/09/21/10%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84css%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="10个好用的的css框架"><a href="#10个好用的的css框架" class="headerlink" title="10个好用的的css框架"></a>10个好用的的css框架</h1><p>优秀的css框架可以使开发变得更加快速，不再为兼容性苦恼，并且一般都会有合理的布局，作为开发可以减少对UI设计的思考。近期我整理了一些css框架供开发者选择和使用，排名不分先后。</p><h2 id="1-bootstrap"><a href="#1-bootstrap" class="headerlink" title="1.bootstrap"></a>1.bootstrap</h2><p>Bootstrap仍然是最流行的 CSS 框架之一。他们提供了大量的文档、示例和演示，可以帮你快速进行响应式 Web 开发。该框架的当前版本是 Bootstrap 5，相较于V4，做出了一些改变：</p><ul><li>拥有了自己的SVG图标库</li><li>不再支持jquery</li><li>不再支持IE</li><li>增加了css自定义属性</li><li>增强的网格系统</li><li>Forms可被更新</li></ul><p><img src="/img/cssLibraries/bootstrap.png" alt="bootstrap"><br>传送门：<a href="https://getbootstrap.com/">https://getbootstrap.com/</a></p><h2 id="2-tailwind"><a href="#2-tailwind" class="headerlink" title="2.tailwind"></a>2.tailwind</h2><p>Tailwind CSS 是一个功能类优先的 CSS 框架，它集成了诸如<strong>flex</strong>, <strong>pt-4</strong>, <strong>text-center</strong> 和 <strong>rotate-90</strong> 这样的的类，它们能直接在脚本标记语言中组合起来，构建出任何设计。</p><p>主要特性：</p><ul><li>组件化</li><li>体积小，性能高</li><li>响应式</li></ul><p><img src="/img/cssLibraries/tailwindcss.png" alt="tailwind"></p><p>传送门：<a href="https://tailwindcss.com/">https://tailwindcss.com/</a></p><h2 id="3-Foundation"><a href="#3-Foundation" class="headerlink" title="3.Foundation"></a>3.Foundation</h2><p>Foundation 是由产品设计公司 ZURB 制作的自适应前端框架。<br>相比于其他同类型工具，Foundation的移动化方案更加出色。借鉴响应式Web设计的思路和方法，Foundation对内容结构在不同类型设备中的的呈现方式进行了相应的预设。</p><p><img src="/img/cssLibraries/foundation.png" alt="foundation"></p><p>传送门：<a href="https://get.foundation/">https://get.foundation/</a></p><h2 id="4-Skeleton"><a href="#4-Skeleton" class="headerlink" title="4. Skeleton"></a>4. Skeleton</h2><p>如果您正在着手一个较小的项目，或者只是觉得不需要大型框架的所有实用程序，则应该使用 Skeleton。</p><p>在Skeleton css官网中，介绍了三个Skeleton的三大优势：</p><ul><li>Light as a feather at ~400 lines &amp; built with mobile in mind.（超轻量级, 为移动端打造）</li><li>Styles designed to be a starting point, not a UI framework.（样式设计为起点，而非 UI 框架）</li><li>Quick to start with zero compiling or installing necessary.<br>（快速入门，零编译或安装必要）</li></ul><p>根据Skeleton的特点和优势，可以把它的典型应用场景归纳为：</p><ul><li>css学习和demo练习；</li><li>创建小型的响应式手机应用；</li></ul><p><img src="/img/cssLibraries/skeleton.png" alt="skeleton"></p><p>传送门：<a href="http://getskeleton.com/">http://getskeleton.com/</a></p><h2 id="5-Tachyons"><a href="#5-Tachyons" class="headerlink" title="5.Tachyons"></a>5.Tachyons</h2><p>Tachyons具备了当前流行的css框架的优点，无需自己编写大量 CSS。轻量、可定制化和拓展等。Tachyons有极其细化的原子类，只需要在类名中添加属性新的样式即可。不必担心命名冲突，也无需担心样式覆盖，这样可以更能直观的看出样式的具体内容。</p><p><img src="/img/cssLibraries/tachyons.png" alt="tachyons"></p><p>传送门：<a href="https://tachyons.io/">https://tachyons.io/</a></p><h2 id="6-UIkit"><a href="#6-UIkit" class="headerlink" title="6.UIkit"></a>6.UIkit</h2><p>相较于其他通用的css框架，UIkit有一些这些框架没有的组件，比如</p><ul><li>Lightbox（利用模态对话框为图片和视频创建一个别致的灯箱）</li><li>Parallax（依赖于页面滚动条位置的动态 CSS 特性）</li><li>Nestable（创建可以通过拖拽排序的可嵌套式列表）</li><li>Sortable（创建可排序的网格和列表重新来排列元素的顺序）</li><li>…</li></ul><p><img src="/img/cssLibraries/uikit.png" alt="uikit"></p><p>传送门：<a href="https://getuikit.com/">https://getuikit.com/</a></p><h2 id="7-Semantic-UI"><a href="#7-Semantic-UI" class="headerlink" title="7.Semantic UI"></a>7.Semantic UI</h2><p>Semantic意为语义，由于Semantic UI类在命名上清晰易懂，因此开发人员不但节省了学习的时间，也让手头上项目的开发更快、更直观。此外布局的多样性是Semantic UI的另一个优势。通过不同的主题，您可以轻松地为各种项目找到必要的组件。</p><p>Semantic UI存在一些缺点，更新频率相较于其他热门框架较低，并且在某些设备运行响应能力一般。</p><p><img src="/img/cssLibraries/semantic.png" alt="semantic"></p><p>传送门：<a href="https://semantic-ui.com/">https://semantic-ui.com/</a></p><h2 id="8-Bulma"><a href="#8-Bulma" class="headerlink" title="8.Bulma"></a>8.Bulma</h2><p>Bulma 是一个基于 Flexbox 的现代化的 CSS 框架。它提供了随时可用的前端组件，您可以轻松地组合这些组件来构建响应式 Web 界面。</p><p><img src="/img/cssLibraries/bulma.png" alt="bulma"></p><p>和bootstrap相比，两者最大的区别是，bulma是纯css，没有js，bootstrap有JS。这里举个<strong>列布局</strong>的例子：</p><ol><li>添加<code>columns</code>容器</li><li>添加任意数量的<code>column</code>元素</li></ol><p>无论列数是多少，每一列的<strong>宽度</strong>都<strong>相等</strong>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">columns</span>&quot;&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">5</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><p>传送门：<a href="https://bulma.io/">https://bulma.io/</a></p><h2 id="9-Picnic"><a href="#9-Picnic" class="headerlink" title="9.Picnic"></a>9.Picnic</h2><p>Picnic是一个轻量级CSS框架，压缩后的大小不到10kb。该框架最大的特点就是具有多个交互式组件，包括栅格、表单、选项卡、工具提示等等，可以帮助开发人员快速创建响应式网站和web应用程序。</p><p>Picnic CSS是一个用<strong>Sass</strong>写的轻量级UI框架，它能更容易的编辑和自定义变量，如颜色和长度。它还有一些不错的纯CSS写的UI组件，如模态窗口和内容滑块。 </p><p><img src="/img/cssLibraries/picnicss.png" alt="picnicss"></p><p>传送门：<a href="https://picnicss.com/">https://picnicss.com/</a></p><h2 id="10-NES-css"><a href="#10-NES-css" class="headerlink" title="10.NES.css"></a>10.NES.css</h2><p>NES.css 模仿了8 位 Nintendo Entertainment System 图形，营造出复古的游戏外观：</p><p>NES.css 只需要 CSS，不依赖任何 JavaScript。作为每个游戏发烧友都会大呼：爱了！</p><p><img src="/img/cssLibraries/NES.png" alt="NES"></p><p>传送门：<a href="https://nostalgic-css.github.io/NES.css/">https://nostalgic-css.github.io/NES.css/</a></p><p>GitHub：<a href="https://github.com/nostalgic-css/NES.css">https://github.com/nostalgic-css/NES.css</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git命令</title>
    <link href="/2021/08/30/git%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/08/30/git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="mac操作，不分先后顺序"><a href="#mac操作，不分先后顺序" class="headerlink" title="mac操作，不分先后顺序"></a>mac操作，不分先后顺序</h3><p>sudo 以管理员身份执行<br>vim 打开编辑器  :wq 保存并退出<br>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。<br>source<br>rm -rf [文件名] 删除文件</p><p>使用新电脑，需要和远程GitHub进行连接，这时候需要ssh进行通信，设置步骤为</p><ol><li>检查ssh keys 是否存在<br>输入下面的命令，如果有文件id_rsa.pub 或 id_dsa.pub，则直接进入步骤3将SSH key添加到GitHub中，否则进入第二步生成SSH key<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -al ~<span class="hljs-string">/.ssh</span><br><span class="hljs-comment"># Lists the files in your .ssh directory, if they exist</span><br></code></pre></td></tr></table></figure></li><li>生成新的ssh key<br>在命令行中输入<strong>ssh-keygen -t rsa -C “<a href="mailto:&#121;&#x6f;&#117;&#x72;&#x5f;&#101;&#x6d;&#x61;&#105;&#x6c;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">&#121;&#x6f;&#117;&#x72;&#x5f;&#101;&#x6d;&#x61;&#105;&#x6c;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;</a>“</strong></li><li>将ssh key添加到GitHub中<br>用自己喜欢的文本编辑器打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到GitHub的Add SSH key页面即可</li></ol><p>不同的操作系统，均有一些命令，直接将SSH key从文件拷贝到粘贴板中，如下：<br>mac: </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">pbcopy &lt; ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br><span class="hljs-comment"># Copies the contents of the id_rsa.pub file to your clipboard</span><br></code></pre></td></tr></table></figure><p>可以使用vim编辑</p><p>vim /etc/hosts<br>绑定域名</p><p>nvm环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NVM_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.nvm&quot;</span><br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span>  <span class="hljs-comment"># This loads nvm</span><br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/bash_completion&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/bash_completion&quot;</span>  <span class="hljs-comment"># This loads nvm bash_completion</span><br><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;ls -alF&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>总结一下自己对promise的理解</title>
    <link href="/2021/08/23/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E5%AF%B9promise%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/08/23/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E5%AF%B9promise%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>学习本身是比较枯燥的，个人认为最大的外因是当下没有需求去获取知识。举个例子，比如打游戏被对面杀爆了，被站在泉水门口堵着杀😥，心态崩了，就想回过头来练好杀崩我的这个英雄，抑或看上了今天晚上游泳时候在隔壁泳道宛若游龙的妹子，不知道如何搭讪便准备好好练习游泳，幻想着有机会去和妹子说句话~(然而当我练成了，再也没见过这个妹子了。。。)</p><p>当我想去学一个东西的时候，遇到的第一个困境就是不知道这个东西有什么用，学了之后会给自己带来多少提升，硬着头皮打开文档，一看好长，就瞬间不想学了。后面遇到这个东西的频率越来越高，而不得不去了解这个东西的时候，这个潜在关系就结合起来了，因为<strong>需要</strong>所以<strong>重要</strong>。</p><h2 id="promise解决了什么问题"><a href="#promise解决了什么问题" class="headerlink" title="promise解决了什么问题"></a>promise解决了什么问题</h2><p>在传统的异步编程中，如果异步之间存在依赖关系，就需要通过层层嵌套回调的方式满足这种依赖，如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱”，而 Promise <strong>将嵌套调用改为链式调用</strong>，增加了可阅读性和可维护性。也就是说，Promise 解决的是<strong>异步编码风格</strong>的问题。</p><h2 id="promise和async-await"><a href="#promise和async-await" class="headerlink" title="promise和async|await"></a>promise和async|await</h2><p>我前端调用接口的时候，往往都是使用的都是promise对象。查看调用接口的类型标注，看到是promise对象，而我把async去掉，当前函数的类型就不是promise了，async和promise肯定是有关系的。查了一下相关资料，get</p><p>相同点：</p><ul><li>都是解决异步流程问题</li></ul><p>不同点：</p><ul><li>Promise是es6里的，async是es7。</li><li>Promise链式操作，自己catch异常。async则要在函数内catch。</li><li>Promise有很多并行神器，比如Promise.all\Promise.allSettled\Promise.race等。这些是async没法搞定的</li><li>Promise是显式的异步，而Async/await 让你的代码看起来是同步的，你依然需要注意异步。</li><li>Promise即使不支持es6，仍然可以用promise的库或polyfill，而async就很难做。</li></ul><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>和promise、async、await相比，我基本上很少用他，理解不是很深，下面只写一些基本介绍。</p><p>Generator 是ES6引入的新语法，Generator是一个可以暂停和继续执行的函数。</p><p>简单的用法，可以当做一个Iterator来用，进行一些遍历操作。复杂一些的用法，他可以在内部保存一些状态，成为一个状态机。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">Generator</span> 基本语法包含两部分：函数名前要加一个星号；函数内部用 <span class="hljs-keyword">yield</span> 关键字返回值。<br></code></pre></td></tr></table></figure><ul><li><p>yield，表达式本身没有返回值，或者说总是返回undefined。</p></li><li><p>next，方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>&#123;<br><br>    <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span> * (<span class="hljs-keyword">yield</span> (x + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">var</span> z = <span class="hljs-keyword">yield</span> (y / <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">return</span> (x + y + z);<br><br>&#125;<br><br><span class="hljs-keyword">var</span> b = foo(<span class="hljs-number">5</span>); <br><br>b.next() <span class="hljs-comment">// &#123; value:6, done:false &#125;</span><br><br>b.next(<span class="hljs-number">12</span>) <span class="hljs-comment">// &#123; value:8, done:false &#125; </span><br><br>b.next(<span class="hljs-number">13</span>) <span class="hljs-comment">// &#123; value:42, done:true &#125;</span><br><br></code></pre></td></tr></table></figure><h2 id="然后再说一下自己对promise的基本理解"><a href="#然后再说一下自己对promise的基本理解" class="headerlink" title="然后再说一下自己对promise的基本理解"></a>然后再说一下自己对promise的基本理解</h2><ul><li><p>依照<strong>Promise/A+<strong>的定义，</strong>Promise</strong>有四种状态：</p><p>  <strong>pending</strong>: 初始状态, 非 <strong>fulfilled</strong> 或 <strong>rejected</strong>.</p><p>  <strong>fulfilled</strong>: 成功的操作.</p><p>  <strong>rejected</strong>: 失败的操作.</p><p>  <strong>settled</strong>: Promise已被<strong>fulfilled</strong>或<strong>rejected</strong>，且不是<strong>pending</strong></p><p>补充一下，promise的A+定义：</p><ol><li><p>一个promise的当前状态只能是pending、fulfilled和rejected三种之一。状态改变只能是pending到fulfilled或者pending到rejected。状态改变不可逆。</p></li><li><p>promise的then方法接收两个可选参数，表示该promise状态改变时的回调(promise.then(onFulfilled, onRejected))。then方法返回一个promise，then 方法可以被同一个 promise 调用多次。</p></li></ol></li></ul><ul><li><p>另外， fulfilled与 rejected一起合称 settled</p></li><li><p>Promise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算</p></li></ul><p><strong>promise只是用来解决异步计算的一种方法，和调用接口没有直接的必然关系，应该反过来说，调用接口需要使用promise来解决异步的问题，可能接口调用封装了多层，自己没有查到最底层的源码。</strong></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>光说不练假把式，直接上题。</p><h3 id="1-Promise的几道基础题"><a href="#1-Promise的几道基础题" class="headerlink" title="1. Promise的几道基础题"></a>1. Promise的几道基础题</h3><h4 id="1-1-题目一"><a href="#1-1-题目一" class="headerlink" title="1.1 题目一"></a>1.1 题目一</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>, promise1);<br></code></pre></td></tr></table></figure><ul><li>从上至下，先遇到new Promise，执行该构造函数中的代码promise1</li><li>然后执行同步代码1，此时promise1没有被resolve或者reject，因此状态还是pending</li></ul><h4 id="1-2-题目二"><a href="#1-2-题目二" class="headerlink" title="1.2 题目二"></a>1.2 题目二</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><ul><li>从上至下，先遇到new Promise，执行其中的同步代码1</li><li>再遇到resolve(‘success’)， 将promise的状态改为了resolved并且将值保存下来</li><li>继续执行同步代码2</li><li>跳出promise，往下执行，碰到promise.then这个微任务，将其加入微任务队列</li><li>执行同步代码4</li><li>本轮宏任务全部执行完毕，检查微任务队列，发现promise.then这个微任务且状态为resolved，执行它。</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="1-3-题目三"><a href="#1-3-题目三" class="headerlink" title="1.3 题目三"></a>1.3 题目三</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><ul><li><p>和题目二相似，只不过在promise中并没有resolve或者reject</p></li><li><p>因此promise.then并不会执行，它只有在被改变了状态之后才会执行。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="1-4-题目四"><a href="#1-4-题目四" class="headerlink" title="1.4 题目四"></a>1.4 题目四</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve(<span class="hljs-string">&#x27;resolve1&#x27;</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> promise2 = promise1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>, promise1);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>, promise2);<br></code></pre></td></tr></table></figure></li><li><p>从上至下，先遇到new Promise，执行该构造函数中的代码promise1</p></li><li><p>碰到resolve函数, 将promise1的状态改变为resolved, 并将结果保存下来</p></li><li><p>碰到promise1.then这个微任务，将它放入微任务队列</p></li><li><p>promise2是一个新的状态为pending的Promise`</p></li><li><p>执行同步代码1， 同时打印出promise1的状态是resolved</p></li><li><p>执行同步代码2，同时打印出promise2的状态是pending</p></li><li><p>宏任务执行完毕，查找微任务队列，发现promise1.then这个微任务且状态为resolved，执行它。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-string">&#x27;promise1&#x27;</span><br><span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="hljs-string">&#x27;resolve1&#x27;</span>&#125;<br><span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-built_in">Promise</span>&#123;&lt;pending&gt;&#125;<br><span class="hljs-string">&#x27;resolve1&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="1-5-题目五"><a href="#1-5-题目五" class="headerlink" title="1.5 题目五"></a>1.5 题目五</h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> = <span class="hljs-params">()</span> =&gt; <span class="hljs-params">(<span class="hljs-keyword">new</span> Promise<span class="hljs-params">(<span class="hljs-params">(resolve, reject)</span> =&gt; &#123;</span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-function">  console.log<span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-function">  resolve<span class="hljs-params">(<span class="hljs-string">&#x27;success&#x27;</span>)</span></span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-function">&#125;)</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">()</span>.<span class="hljs-title">then</span><span class="hljs-params">(res =&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  console.log<span class="hljs-params">(res)</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span><br><span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-string">&#x27;start&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>请仔细看看哦，fn函数它是直接返回了一个new Promise的，而且fn函数的调用是在start之前，所以它里面的内容应该会先执行。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-number">1</span><br><span class="hljs-symbol">&#x27;start</span>&#x27;<br><span class="hljs-symbol">&#x27;success</span>&#x27;<br></code></pre></td></tr></table></figure><h4 id="1-6-题目六"><a href="#1-6-题目六" class="headerlink" title="1.6 题目六"></a>1.6 题目六</h4><p>如果把fn的调用放到start之后呢？</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const fn = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    resolve(<span class="hljs-string">&quot;success&quot;</span>);<br>  &#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;start&quot;</span>);<br>fn().<span class="hljs-keyword">then</span>(res =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(res);<br>&#125;);<br></code></pre></td></tr></table></figure><p>现在start就在1之前打印出来了，因为fn函数是之后执行的。</p><p>  注意⚠️：之前我们很容易就以为看到new Promise()就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;start&quot;</span><br><span class="hljs-number">1</span><br><span class="hljs-string">&quot;success&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p>未完待续。。。</p><p>手写：</p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React事件通信</title>
    <link href="/2021/07/30/React%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/07/30/React%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>React组件之间的通信一般分为下面几种情况：</p><ul><li>父子组件之间的通信</li><li>非嵌套组件之间的通信</li></ul><h2 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。下面贴两段代码:</p><p>父组件 FatherComp.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> Son <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./SonComp&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FatherComp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;我就是高阶领主&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>子组件 SonComp.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> Son = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;props.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Son;<br></code></pre></td></tr></table></figure><p>这个也没啥好说的，最简单的透传，下面主要介绍非嵌套的组件之间的通信。</p><h2 id="非嵌套组件之间的通信"><a href="#非嵌套组件之间的通信" class="headerlink" title="非嵌套组件之间的通信"></a>非嵌套组件之间的通信</h2><p>简单来说就是组件之间没有什么关联，需要通信就需要有个媒介，这里我们采用自定义事件的方式来进行通信：<br>首先需要安装一个event包</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install events <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>新建一个 event.js，引入 events 包，并向外提供一个事件对象，供通信时使用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> &#123; EventEmitter &#125; from <span class="hljs-string">&quot;events&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title">EventEmitter</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>App.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><br><span class="hljs-keyword">import</span> Comp1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Comp1&quot;</span>;<br><span class="hljs-keyword">import</span> Comp2 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Comp2&quot;</span>;<br><span class="hljs-keyword">import</span> FatherComp <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./FatherComp&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FatherComp</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Comp1</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Comp2</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>Comp1.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./event&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Comp1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [msg, setMsg] = useState(<span class="hljs-literal">null</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 声明一个自定义事件</span><br>    <span class="hljs-comment">// 在组件装载完成以后</span><br>    <span class="hljs-built_in">this</span>.eventEmitter = emitter.addListener(<span class="hljs-string">&quot;clickMe&quot;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>      setMsg(msg);<br>    &#125;);<br>    <span class="hljs-comment">// 组件销毁前移除事件监听</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      emitter.removeListener(<span class="hljs-built_in">this</span>.eventEmitter);<br>    &#125;;<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      &#123;msg&#125;</span><br><span class="xml">      组件1</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>Comp2.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./event&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Comp2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> cb = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 触发自定义事件</span><br>      emitter.emit(<span class="hljs-string">&quot;clickMe&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      组件2<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;cb()&#125;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们写一个简单的事件demo来深入了解一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eventPool = &#123;<br>  <span class="hljs-attr">map</span>: &#123;&#125;,<br>  <span class="hljs-comment">// 事件订阅</span><br>  <span class="hljs-attr">on</span>: <span class="hljs-function">(<span class="hljs-params">name, cb</span>) =&gt;</span> &#123;<br>    eventPool.map[name] = cb;<br>  &#125;,<br>  <span class="hljs-comment">// 事件发射</span><br>  <span class="hljs-attr">emit</span>: <span class="hljs-function">(<span class="hljs-params">name, ...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> cb = eventPool.map[name];<br>    cb &amp;&amp; cb(...args);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// xxx为事件名，有两个参数</span><br>eventPool.on(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-function">(<span class="hljs-params">p1, p2</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(p1, p2));<br><span class="hljs-comment">// 发射完直接打印了这两个参数</span><br>eventPool.emit(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自定义事件在组件之间没有直接联系的情况下使用还是很方便的，总之就是香~<br><a href="https://codesandbox.io/s/comp-interaction-demo-8ov47">这里</a>是本篇文章涉及的代码</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo 简介，安装，部署</title>
    <link href="/2021/07/28/hexo%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/07/28/hexo%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>hexo是使用node.js开发的一个快速、简洁、高效、开源的静态博客生成器，使用了<a href="https://www.zybuluo.com/mdeditor">MarkDown</a>解析文章。我们可以用hexo在本地起好服务，托管到github就能通过github域名访问(免费，省事)，当然也可以使用自定义的域名解析(花钱，高大上)。</p><p>本文可能对初学计算机的童鞋们不太友好，这里省去了node.js和git的安装及配置，包括设置Git用户信息，生成SSH key公钥，这里不再赘述，可以自行百度~</p><h3 id="git仓库配置"><a href="#git仓库配置" class="headerlink" title="git仓库配置"></a>git仓库配置</h3><p>我采用的是hexo + githubPages搭建，首先需要<strong>在GitHub上创建Github Pages服务</strong>，具体步骤如下图：<br><img src="/img/hexo-deploy.png" alt="hexo-deploy"><br>点击之后仓库名一定要填 用户名.github.io 的格式(形如zhangzheyi1.github.io)，不要填 用户名 的格式(形如zhangzheyi1)，这里踩了好几次坑了，浪费了不少事件，因为现在我已经有这个仓库了，这个报错可以忽略掉，下面的readme记得点上❤，最后一步点创建<br><img src="/img/hexo-deploy2.png" alt="hexo-deploy2"></p><h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli <span class="hljs-comment">#全局安装hexo脚手架</span><br></code></pre></td></tr></table></figure><h3 id="初始化创建博客"><a href="#初始化创建博客" class="headerlink" title="初始化创建博客"></a>初始化创建博客</h3><h3 id="1-创建站点根目录"><a href="#1-创建站点根目录" class="headerlink" title="1.创建站点根目录"></a>1.创建站点根目录</h3><p>首先需要初创建一个博客文件夹，注意这个<strong>文件夹的名字</strong>最好要和你刚才创建的GitHubPages的地址一致也就是<strong>your_github_name.github.io</strong>(形如zhangzheyi1.github.io)。这个文件夹以后也统称为站点根目录。</p><h3 id="2-初始化站点根目录"><a href="#2-初始化站点根目录" class="headerlink" title="2.初始化站点根目录"></a>2.初始化站点根目录</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> mkdir &lt;folder&gt;  <span class="hljs-comment">#创建站点根目录，形如(mkdir zhangzheyi1.github.io)</span><br><span class="hljs-variable">$</span> hexo init &lt;folder&gt;  <span class="hljs-comment">#使用Hexo初始化站点根目录(hexo init zhangzheyi1.github.io)</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;  <span class="hljs-comment">#进入到站点根目录(cd zhangzheyi1.github.io)</span><br><span class="hljs-variable">$</span> npm install  <span class="hljs-comment">#安装npm所依赖的文件</span><br></code></pre></td></tr></table></figure><p>等他安装好，在输入两条就能访问本地的博客了</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span> # 生成博客<br>$ hexo server # 本地预览<br></code></pre></td></tr></table></figure><p>默认端口是4000，直接浏览器键入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以访问了，现在是默认的主题</p><p><img src="/img/hexo-deploy3.png" alt="hexo-deploy3"></p><h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h3><p>现在我们只能在本地预览，想在gitPage上预览还需要进行一些配置，找到根目录下的_confi.yml文件，拉到最下面我们看到的是以下code</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>deploy就是部署的意思，这里部署的话需要填下信息，修改为以下代码就可以</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:zhangzheyi1/zhangzheyi1.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>repo就是仓库地址，这儿用的是SSH，找到刚才创建的仓库，把这个地址复制下来粘到repo里就可以了</p><p><img src="/img/hexo-deploy4.png" alt="hexo-deploy4"></p><p>安装以下插件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> hexo-deployer-git —save<br></code></pre></td></tr></table></figure><p>执行以下命令发布本地博客到远程仓库：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>可能到这步登陆<strong>your_github_name.github.io</strong>，形如zhangzheyi1.github.io，有些同学还是没办法看到自己的博客，就是因为github的配置有点恶心人，当时我也在这儿不知道怎么搞，是因为默认的分支是main，而不是master，需要点击仓库的settings =&gt; pages 然后修改一下默认的分支就可以<br><img src="/img/hexo-deploy5.png" alt="hexo-deploy5"></p><p>到这步基本上就ok了，网上发的好多博客都是很久以前写的，github的版本和hexo的配置文件都不一样，按照本篇文章应该可以完成，现在的博客只是一个默认主题，xdm想换主题的话可以在网上搜一下主题，本博客用的是Fluid主题，第一次发文，确实挺耗时间的，希望自己以后能坚持下去~</p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>

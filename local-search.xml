<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>刷题01</title>
    <link href="/2022/01/25/%E5%88%B7%E9%A2%98/"/>
    <url>/2022/01/25/%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-在字符串-s-中找出第一个只出现一次的字符。如果没有，返回一个单空格。-s-只包含小写字母。"><a href="#1-在字符串-s-中找出第一个只出现一次的字符。如果没有，返回一个单空格。-s-只包含小写字母。" class="headerlink" title="1. 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。"></a>1. 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</h1><p>示例 1:</p><p>输入：s = “abaccdeff”<br>输出：’b’<br>示例 2:</p><p>输入：s = “”<br>输出：’ ‘</p><p>方法一：使用哈希表存储频数<br>思路与算法:</p><p>我们可以对字符串进行两次遍历。</p><p>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回该字符，否则在遍历结束后返回空格。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;string&#125; s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;character&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> frequency = _.countBy(s);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [i, ch] of <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(s).entries()) &#123;<br>    <span class="hljs-keyword">if</span> (frequency[ch] === <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> ch;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>方法二：使用哈希表存储索引<br>思路与算法</p><p>我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。</p><p>具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 -1−1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 cc，如果 cc 不在哈希映射中，我们就将 cc 与它的索引作为一个键值对加入哈希映射中，否则我们将 cc 在哈希映射中对应的值修改为 -1−1。</p><p>在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 -1−1 的最小值，即为第一个不重复字符的索引，然后返回该索引对应的字符。如果哈希映射中的所有值均为 -1−1，我们就返回空格。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> firstUniqChar = function(s) &#123;<br>  const <span class="hljs-built_in">position</span> = <span class="hljs-built_in">new</span> Map();<br>  const n = s.<span class="hljs-built_in">length</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> [i, ch] of Array.from(s).entries()) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">position</span>.has(ch)) &#123;<br>          <span class="hljs-built_in">position</span>.set(ch, -<span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">position</span>.set(ch, i);<br>      &#125;<br>  &#125;<br>  <span class="hljs-built_in">let</span> <span class="hljs-built_in">first</span> = n;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> pos of <span class="hljs-built_in">position</span>.<span class="hljs-built_in">values</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (pos !== -<span class="hljs-number">1</span> &amp;&amp; pos &lt; <span class="hljs-built_in">first</span>) &#123;<br>          <span class="hljs-built_in">first</span> = pos;<br>      &#125;<br>  &#125;<br>  <span class="hljs-built_in">return</span> <span class="hljs-built_in">first</span> == n ? &#x27; &#x27; : s[<span class="hljs-built_in">first</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>又看到了一个答案，被秀到了。。。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;string&#125; s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;character&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x of s)&#123;<br>        <span class="hljs-keyword">if</span>(s.indexOf(x) === s.lastIndexOf(x)) <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-三个数的最大乘积"><a href="#2-三个数的最大乘积" class="headerlink" title="2. 三个数的最大乘积"></a>2. 三个数的最大乘积</h1><p>给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：6<br>示例 2：</p><p>输入：nums = [1,2,3,4]<br>输出：24<br>示例 3：</p><p>输入：nums = [-1,-2,-3]<br>输出：-6</p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>leecode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百花CMS技术点总结</title>
    <link href="/2021/12/30/%E7%99%BE%E8%8A%B1CMS%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    <url>/2021/12/30/%E7%99%BE%E8%8A%B1CMS%E6%8A%80%E6%9C%AF%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>写了一年的百花了，前几周还写写总结，是时候写一下沉淀的东西了。</p><h2 id="调试经验"><a href="#调试经验" class="headerlink" title="调试经验"></a>调试经验</h2><ol><li>setupProxy.js</li></ol><p>本地可以模拟正式和线上环境，通过转发不同的域名来配置</p><p>@ <a href="https://cloud.tencent.com/developer/article/1664425">https://cloud.tencent.com/developer/article/1664425</a></p><p>遇到最常见的问题，状态码报304，因为没有配置相对应的路由</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">app.use(proxy(<br>  &#x27;/hello&#x27;,<br>  make<span class="hljs-constructor">ProxyConfig(&#x27;<span class="hljs-params">http</span>:<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-params">hello</span>.<span class="hljs-params">oa</span>.<span class="hljs-params">com</span><span class="hljs-operator">/</span><span class="hljs-params">hello</span>&#x27;)</span>,<br>));<br></code></pre></td></tr></table></figure><ol start="2"><li>中间件打印日志</li></ol><p>这儿好像对中间件加了一层打印，state变化可以在控制台上看到。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">middlewares: [<br>  (info, <span class="hljs-built_in">next</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (info.<span class="hljs-built_in">module</span> === <span class="hljs-string">&#x27;group&#x27;</span>) &#123;<br>      // console.<span class="hljs-built_in">error</span>(info);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&#x27;development&#x27;</span> &amp;&amp; info.<span class="hljs-built_in">module</span> !== <span class="hljs-string">&#x27;loading&#x27;</span>) &#123;<br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;%c ------&gt;&gt;&gt;&#x27;</span>, <span class="hljs-string">&#x27;color:green;&#x27;</span>);<br>      console.<span class="hljs-built_in">log</span>(info);<br>    &#125;<br>    <span class="hljs-built_in">next</span>();<br>  &#125;,<br>],<br></code></pre></td></tr></table></figure><ol start="3"><li>跨域问题</li></ol><p>在百花环境调后台接口一般是不需要配置跨域的，如果需要调用别的后台的接口，可能会出现跨域问题。这时候最简单的，用浏览器原生的fetch调用一下，看是否能够调通。<br>一般来说，如果掉不通，会有报错，例如</p><ul><li> 缺少<strong>withCredentials</strong>这个参数，这个要看下请求是否包了这个参数。axios是不自带的，需要加上这个</li></ul><h2 id="数据流的生产和消费"><a href="#数据流的生产和消费" class="headerlink" title="数据流的生产和消费"></a>数据流的生产和消费</h2><p>百花最关键的还是数据流，因为导师的代码太复杂了，被大家称为加密代码。。。这块还是需要好好理一下。</p><p>百花系统最关键的还是个大列表，用来展示所有数据，关键部分有详情页，修改页，下载页等，相对应到rainbow（可以理解为存储变量的中间管理库，方便前后端协调和使用）的参数，例如：是否展示，是否修改，是否下载等</p><ul><li> init(初始化)，取到需要使用的全局变量，这里使用了promise.all取到所有的静态数据存到global的state里，其他模块调用可以直接ctx.global取到响应的数据</li></ul><h2 id="组件方面"><a href="#组件方面" class="headerlink" title="组件方面"></a>组件方面</h2><h3 id="1-GeneralTable"><a href="#1-GeneralTable" class="headerlink" title="1.GeneralTable"></a>1.GeneralTable</h3><p>Table这个组件使用频率很高，因为百花使用了concent作为了状态管理库，这里封装了一个generalTable作为适配，继承了table的通用能力，无需重写翻页，加载更多等功能。并且generalTable是作为cc注册的一个模块，具有tid这个唯一标识，所以可以存储多个table的数据。</p><p>这里贴一下代码，方便理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// setup初次挂载执行，只执行一次</span><br><span class="hljs-keyword">const</span> setup = <span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-attr">tid</span>: tableId, fetchAfterMounted = <span class="hljs-literal">true</span>, hasMoreMode = <span class="hljs-literal">false</span>, <span class="hljs-attr">fetchFn</span>: propsFetchFn,<br>    pageSizeOptions = [<span class="hljs-string">&#x27;50&#x27;</span>, <span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-string">&#x27;200&#x27;</span>],<br>  &#125; = ctx.props;<br>  <span class="hljs-keyword">const</span> &#123; ccUniqueKey &#125; = ctx;<br>  <span class="hljs-keyword">if</span> (!ctx.state.meta[tableId]) &#123;<br>    <span class="hljs-keyword">const</span> pageSize = <span class="hljs-built_in">parseInt</span>(pageSizeOptions[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>) || <span class="hljs-number">50</span>;<br>    ctx.state.meta[tableId] = getInitMetaData(hasMoreMode, pageSize);<br>  &#125;<br><span class="hljs-comment">// 刷新Table，传入事件名和tableId</span><br>  ctx.on([<span class="hljs-string">&#x27;refreshTable&#x27;</span>, tableId], <span class="hljs-keyword">async</span> (fetchFn) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> _fetchFn = fetchFn || propsFetchFn;<br>    <span class="hljs-keyword">await</span> ctx.dispatch(<span class="hljs-string">&#x27;clearTable&#x27;</span>, &#123; tableId &#125;, ccUniqueKey);<br>    <span class="hljs-keyword">await</span> ctx.dispatch(<span class="hljs-string">&#x27;handlePageCurrentChange&#x27;</span>, &#123; tableId, <span class="hljs-attr">current</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">fetchFn</span>: _fetchFn &#125;, ccUniqueKey);<br>  &#125;);<br><span class="hljs-comment">// 清空列表</span><br>  ctx.on([<span class="hljs-string">&#x27;clearTable&#x27;</span>, tableId], <span class="hljs-function">() =&gt;</span> &#123;<br>    ctx.dispatch(<span class="hljs-string">&#x27;clearTable&#x27;</span>, &#123; tableId &#125;, ccUniqueKey);<br>  &#125;);<br><span class="hljs-comment">// 清空当前列表</span><br>  ctx.on([<span class="hljs-string">&#x27;refreshTableCurPage&#x27;</span>, tableId], <span class="hljs-function">(<span class="hljs-params">fetchFn</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> _fetchFn = fetchFn || propsFetchFn;<br>    <span class="hljs-keyword">const</span> tableMeta = ctx.state.meta[tableId];<br>    ctx.dispatch(<span class="hljs-string">&#x27;handlePageCurrentChange&#x27;</span>, &#123; tableId, <span class="hljs-attr">current</span>: tableMeta.current, <span class="hljs-attr">fetchFn</span>: _fetchFn &#125;, ccUniqueKey);<br>  &#125;);<br><br>  ctx.effect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (fetchAfterMounted) &#123;<br>      handlePageCurrentChange(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> ctx.dispatch(<span class="hljs-string">&#x27;clearTable&#x27;</span>, &#123; tableId &#125;, ccUniqueKey);<br>  &#125;, []);<br><span class="hljs-comment">// 翻页相关</span><br>  <span class="hljs-keyword">const</span> handlePageCurrentChange = <span class="hljs-function">(<span class="hljs-params">current</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; fetchFn &#125; = ctx.props;<span class="hljs-comment">// fetchFn有可能会变，这里每次取最新的</span><br>    ctx.dispatch(<span class="hljs-string">&#x27;handlePageCurrentChange&#x27;</span>, &#123; tableId, current, fetchFn &#125;, ccUniqueKey);<br>  &#125;;<br><span class="hljs-comment">// 翻页相关</span><br>  <span class="hljs-keyword">const</span> handelPageSizeChange = <span class="hljs-function">(<span class="hljs-params">page, pageSize</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; fetchFn &#125; = ctx.props;<br>    ctx.dispatch(<span class="hljs-string">&#x27;handlePageSizeChange&#x27;</span>, &#123; tableId, pageSize, fetchFn &#125;, ccUniqueKey);<br>  &#125;;<br><span class="hljs-comment">// 翻页相关</span><br>  <span class="hljs-keyword">const</span> handleNextPage = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; fetchFn &#125; = ctx.props;<br>    ctx.dispatch(<span class="hljs-string">&#x27;handleNextPage&#x27;</span>, &#123; tableId, fetchFn &#125;);<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    handlePageCurrentChange,<br>    handelPageSizeChange,<br>    handleNextPage,<br>    pageSizeOptions,<br>  &#125;;<br>&#125;;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * #################[Code example]#####################</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  const fetcher = ()=&gt; xxxService.fetchData();</span><br><span class="hljs-comment"> *  &lt;GeneralTable tid=&quot;xxxId&quot; fetchFn=&#123;fetcher&#125; columns=&#123;yourColumnsDef&#125; /&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * ####################################################</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;object&#125;</span> <span class="hljs-variable">props</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>props.tid</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>[props.hasMoreMode=false] - 是否处于 hasMore 模式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>[props.disableBtnWhenNoMore=false] - 当 hasMore 为true时，如果没有了更多数据，是否禁用加载更多按钮</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>[props.rowKey=&#x27;id&#x27;] - rowKey</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> </span>[props.pageSizeOptions=[&#x27;50&#x27;, &#x27;100&#x27;, &#x27;200&#x27;]] - pageSizeOptions</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;import(&#x27;./type&#x27;).FetchFn&#125;</span> </span>[props.fetchFn]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GeneralTable</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; state, settings &#125; = useConcent(&#123; <span class="hljs-attr">module</span>: <span class="hljs-string">&#x27;GeneralTable&#x27;</span>, setup, props &#125;);<br>  <span class="hljs-keyword">const</span> &#123;<br>    tid, columns, rowKey = <span class="hljs-string">&#x27;id&#x27;</span>, scroll = &#123; <span class="hljs-attr">x</span>: <span class="hljs-string">&#x27;100%&#x27;</span> &#125;, hasMoreMode = <span class="hljs-literal">false</span>,<br>    disableBtnWhenNoMore, size = <span class="hljs-string">&#x27;default&#x27;</span>,<br>  &#125; = props;<br>  <span class="hljs-keyword">const</span> &#123; list, loading, current, total, pageSize, hasMore &#125; = state.meta[tid];<br>  <span class="hljs-keyword">const</span> &#123; handelPageSizeChange, handlePageCurrentChange, handleNextPage, pageSizeOptions &#125; = settings;<br>  <span class="hljs-keyword">const</span> renderBtn = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (disableBtnWhenNoMore &amp;&amp; !hasMore) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">width:</span> &#x27;<span class="hljs-attr">100</span>%&#x27; &#125;&#125;&gt;</span>没有更多了<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleNextPage&#125;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">width:</span> &#x27;<span class="hljs-attr">100</span>%&#x27; &#125;&#125;&gt;</span>加载更多<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Table</span> <span class="hljs-attr">rowKey</span>=<span class="hljs-string">&#123;rowKey&#125;</span> <span class="hljs-attr">columns</span>=<span class="hljs-string">&#123;columns&#125;</span> <span class="hljs-attr">dataSource</span>=<span class="hljs-string">&#123;list&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">loading</span>=<span class="hljs-string">&#123;loading&#125;</span> <span class="hljs-attr">pagination</span>=<span class="hljs-string">&#123;false&#125;</span> <span class="hljs-attr">scroll</span>=<span class="hljs-string">&#123;scroll&#125;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;size&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">      /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">height:</span> &#x27;<span class="hljs-attr">19px</span>&#x27;, <span class="hljs-attr">width:</span> &#x27;<span class="hljs-attr">100</span>%&#x27; &#125;&#125; /&gt;</span></span><br><span class="xml">      &#123;hasMoreMode</span><br><span class="xml">        ? renderBtn()</span><br><span class="xml">        : (</span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Pagination</span> <span class="hljs-attr">onShowSizeChange</span>=<span class="hljs-string">&#123;handelPageSizeChange&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handlePageCurrentChange&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">current</span>=<span class="hljs-string">&#123;current&#125;</span> <span class="hljs-attr">total</span>=<span class="hljs-string">&#123;total&#125;</span> <span class="hljs-attr">showSizeChanger</span> <span class="hljs-attr">pageSizeOptions</span>=<span class="hljs-string">&#123;pageSizeOptions&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">pageSize</span>=<span class="hljs-string">&#123;parseInt(pageSize,</span> <span class="hljs-attr">10</span>)&#125;</span></span><br><span class="hljs-tag"><span class="xml">          /&gt;</span></span><br><span class="xml">        )</span><br><span class="xml">      &#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.memo(GeneralTable);<br></code></pre></td></tr></table></figure><blockquote><p>fetchFn是关键函数，通过透传current，pageSize，pageList可以直接实现翻页效果，这一部分逻辑可以写到业务层的reducer里</p></blockquote><h3 id="2-on，emit-事件订阅，发射"><a href="#2-on，emit-事件订阅，发射" class="headerlink" title="2. on，emit 事件订阅，发射"></a>2. on，emit 事件订阅，发射</h3><p>事件的订阅，发射在vue是个常用api，主要用来跨组件的通信，react没有，之前在网上也有包，可以直接用，这里是在封装到cc里面了</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> pickOneRef from &#x27;../core/ref/pick-one-ref&#x27;;</span><br><br>export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event, <span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!event) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> ref = pickOneRef();<br>  <span class="hljs-keyword">if</span> (ref) ref.ctx.emit(event, ...args);<br>&#125;<br></code></pre></td></tr></table></figure><p>看了下源码，这儿也没看到什么特别高深的东西，写一个简单demo实现一下，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eventPool = &#123;<br>  <span class="hljs-attr">map</span>: &#123;&#125;,<br>  <span class="hljs-comment">// 事件订阅</span><br>  <span class="hljs-attr">on</span>: <span class="hljs-function">(<span class="hljs-params">name, cb</span>) =&gt;</span> &#123;<br>    eventPool.map[name] = cb;<br>  &#125;,<br>  <span class="hljs-comment">// 事件发射</span><br>  <span class="hljs-attr">emit</span>: <span class="hljs-function">(<span class="hljs-params">name, ...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> cb = eventPool.map[name];<br>    cb &amp;&amp; cb(...args);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// xxx为事件名，有两个参数</span><br>eventPool.on(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-function">(<span class="hljs-params">p1, p2</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(p1, p2));<br><span class="hljs-comment">// 发射完直接打印了这两个参数</span><br>eventPool.emit(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="3-Di-组件，代表数据录入组件"><a href="#3-Di-组件，代表数据录入组件" class="headerlink" title="3. Di-组件，代表数据录入组件"></a>3. Di-组件，代表数据录入组件</h3><p>重新封装Di组件，主要还是为了把数据定制化作为props传入组件，统一了起来，也是为了适配cc。</p><p>因为是使用的antd作为组件库，有时候会有一部分功能想要个性化的实现，这时候重新封装一下作为一个通用能力还是不错的</p><p>这里举一些小例子：</p><ul><li>通用能力：是否必填，前缀加红※（主要是样式）</li><li>Select组件：三级级联、匹配上空值时显示空选项</li><li>UploadMultiImg: 多选uploadImg<br>…</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型和原型链</title>
    <link href="/2021/12/29/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2021/12/29/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="一-普通对象与函数对象"><a href="#一-普通对象与函数对象" class="headerlink" title="一. 普通对象与函数对象"></a>一. 普通对象与函数对象</h2><p>JavaScript 中，万物皆对象！但对象也是有区别的。分为<strong>普通对象和函数对象</strong>，Object 、Function 是 JS 自带的函数对象。下面举例说明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;; <br><span class="hljs-keyword">var</span> o2 =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-keyword">var</span> o3 = <span class="hljs-keyword">new</span> f1();<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;; <br><span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-keyword">var</span> f3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;str&#x27;</span>,<span class="hljs-string">&#x27;console.log(str)&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">//function </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>); <span class="hljs-comment">//function  </span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> f1); <span class="hljs-comment">//function </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> f2); <span class="hljs-comment">//function </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> f3); <span class="hljs-comment">//function   </span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> o1); <span class="hljs-comment">//object </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> o2); <span class="hljs-comment">//object </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> o3); <span class="hljs-comment">//object</span><br></code></pre></td></tr></table></figure><p>在上面的例子中 o1 o2 o3 为普通对象，f1 f2 f3 为函数对象。怎么区分，其实很简单，<strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。</strong></p><p>一定要分清楚普通对象和函数对象，下面我们会常常用到它。</p><h2 id="二-构造函数"><a href="#二-构造函数" class="headerlink" title="二. 构造函数"></a>二. 构造函数</h2><p>我们先复习一下构造函数的知识：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">(name, age, job)</span> </span>&#123;<br> <span class="hljs-keyword">this</span>.name = name;<br> <span class="hljs-keyword">this</span>.age = age;<br> <span class="hljs-keyword">this</span>.job = job;<br> <span class="hljs-keyword">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123; alert(<span class="hljs-keyword">this</span>.name) &#125; <br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Zaxlct&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;Software Engineer&#x27;</span>);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Mick&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;Doctor&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面的例子中 person1 和 person2 都是 Person 的<strong>实例</strong>。这两个实例都有一个 <code>constructor</code> （构造函数）属性，该属性（是一个指针）指向 Person。 即：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(person1.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span> Person); <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-literal">true</span><br>console.<span class="hljs-built_in">log</span>(person2.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span> Person); <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>我们要记住两个概念（构造函数，实例）：<br><strong>person1 和 person2 都是 构造函数 Person 的实例</strong><br>一个公式：<br><strong>实例的构造函数属性（constructor）指向构造函数。</strong></p><h2 id="三-原型对象"><a href="#三-原型对象" class="headerlink" title="三. 原型对象"></a>三. 原型对象</h2><p>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个<strong>函数对象</strong>都有一个<code>prototype</code> 属性，这个属性指向函数的原型对象。（先用不管什么是 <code>__proto__</code> 第二节的课程会详细的剖析）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Person()</span> &#123;&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype.name = &#x27;Zaxlct&#x27;;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype.age  = <span class="hljs-number">28</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype.job  = &#x27;Software Engineer&#x27;;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype.sayName = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span> &#123;<br>  alert(this.name);<br>&#125;<br>  <br>var person1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Person()</span>;<br>person1.say<span class="hljs-constructor">Name()</span>; <span class="hljs-comment">// &#x27;Zaxlct&#x27;</span><br><br>var person2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Person()</span>;<br>person2.say<span class="hljs-constructor">Name()</span>; <span class="hljs-comment">// &#x27;Zaxlct&#x27;</span><br><br>console.log(person1.sayName<span class="hljs-operator"> == </span>person2.sayName); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>我们得到了本文第一个「<strong>定律</strong>」：</p><p>每个对象都有 <strong>proto</strong> 属性，但只有函数对象才有 prototype 属性</p><p>那什么是<strong>原型对象</strong>呢？<br>我们把上面的例子改一改你就会明白了：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Person</span>.proto<span class="hljs-keyword">type</span> = &#123;<br>   name:  &#x27;<span class="hljs-type">Zaxlct</span>&#x27;,<br>   age: 28,<br>   job: &#x27;<span class="hljs-type">Software</span> <span class="hljs-type">Engineer</span>&#x27;,<br>   sayName: function() &#123;<br>     alert(this.name);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型对象，顾名思义，它就是一个普通对象（废话 = =!）。从现在开始你要牢牢记住原型对象就是 Person.prototype ，如果你还是害怕它，那就把它想想成一个字母 A： <code>var A = Person.prototype</code></p><p>在上面我们给 A 添加了 四个属性：name、age、job、sayName。其实它还有一个默认的属性：<code>constructor</code></p><blockquote><p>在默认情况下，所有的<strong>原型对象</strong>都会<strong>自动获得</strong>一个 <code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数（Person）</p></blockquote><p>上面这句话有点拗口，我们「翻译」一下：A 有一个默认的 <code>constructor</code> 属性，这个属性是一个指针，指向 Person。即：</p><p><code>Person.prototype.constructor == Person</code></p><p>在上面第二小节《构造函数》里，我们知道<strong>实例的构造函数属性（constructor）指向构造函数</strong> ：<code>person1.constructor == Person</code><br>这两个「公式」好像有点联系：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">person1.constructor</span> == Person<br><span class="hljs-attr">Person.prototype.constructor</span> == Person<br></code></pre></td></tr></table></figure><p>person1 为什么有 constructor 属性？那是因为 person1 是 Person 的实例。<br>那 Person.prototype 为什么有 constructor 属性？？同理， Person.prototype （你把它想象成 A） 也是Person 的实例。<br>也就是在 Person 创建的时候，创建了一个它的实例对象并赋值给它的 prototype，基本过程如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> var A = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Person()</span>;<br> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>prototype = A;<br><span class="hljs-comment">// 注：上面两行代码只是帮助理解，并不能正常运行</span><br></code></pre></td></tr></table></figure><p><strong>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p><p>原型对象其实就是普通对象（但 Function.prototype 除外，它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））。看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-built_in">console</span>.log(Person.prototype) <span class="hljs-comment">//Person&#123;&#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> Person.prototype) <span class="hljs-comment">//Object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.prototype) <span class="hljs-comment">// Function，这个特殊</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// Object</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.prototype.prototype) <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><p><code>Function.prototype</code> 为什么是函数对象呢？</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">var A = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Function</span> <span class="hljs-title"></span>();<br><span class="hljs-keyword">Function</span>.prototype = A;<br></code></pre></td></tr></table></figure><p><strong>上文提到凡是通过 new Function( ) 产生的对象都是函数对象。因为 A 是函数对象，所以<code>Function.prototype</code> 是函数对象。</strong></p><p>那原型对象是用来做什么的呢？主要作用是用于继承。举个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name; <span class="hljs-comment">// tip: 当函数执行时这个 this 指的是谁？</span><br>&#125;;<br>Person.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;  <span class="hljs-comment">// tip: 当函数执行时这个 this 指的是谁？</span><br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> person(<span class="hljs-string">&#x27;Mick&#x27;</span>);<br>person1.getName(); <span class="hljs-comment">//Mick</span><br></code></pre></td></tr></table></figure><p>从这个例子可以看出，通过给 Person.prototype 设置了一个函数对象的属性，那有 Person 的实例（person1）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。</p><p>小问题，上面两个 this 都指向谁？</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-type">person</span>(<span class="hljs-string">&#x27;Mick&#x27;</span>);<br>person1.name = <span class="hljs-string">&#x27;Mick&#x27;</span>; <span class="hljs-comment">// 此时 person1 已经有 name 这个属性了</span><br>person1.getName(); <span class="hljs-comment">//Mick </span><br></code></pre></td></tr></table></figure><p>故两次 this 在函数执行时都指向 person1。</p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解React Hooks及其常用的几个钩子函数</title>
    <link href="/2021/11/19/React%20Hooks/"/>
    <url>/2021/11/19/React%20Hooks/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>React Hooks 是 React 团队在两年前的 16.8 版本推出的一套全新的机制。作为最主流的前端框架，React 的 API 十分稳定，这次更新的发布，让众多恐惧新轮子的前端大佬们虎躯一震，毕竟每一次更新又是高成本的学习，这玩意到底好使么？</p><p>答案是好用的，对于 React 的开发者而言，只是多了一个选择。过去的开发方式是基于Class组件的，而hooks是基于函数组件，这意味着<strong>这两种开发方式可以并存</strong>，而新的代码可以根据具体情况采用 Hooks 的方式来实现就行了。这篇文章主要就来介绍一下<strong>Hooks 的优势</strong> 和 <strong>常用的几个钩子函数</strong>。</p><h1 id="Hooks-的优势"><a href="#Hooks-的优势" class="headerlink" title="Hooks 的优势"></a>Hooks 的优势</h1><h2 id="1-类组件的不足"><a href="#1-类组件的不足" class="headerlink" title="1. 类组件的不足"></a>1. 类组件的不足</h2><ul><li><strong>代码量多</strong>：</li></ul><p>相较于函数组件的写法，使用类组件代码量要略多一点，这个是最直观的感受。</p><ul><li><strong>this指向</strong>：</li></ul><p>类组件中总是需要考虑this的指向问题，而函数组件则可以忽略。</p><ul><li><strong>趋向复杂难以维护</strong>：</li></ul><p>在高版本的React中，又更新了一些生命周期函数，因为这些函数互相解耦，很容易造成分散不集中的写法，漏掉关键逻辑和多了冗余逻辑，导致后期debug困难。相反，hooks可以把关键逻辑都放在一起，不显得那么割裂，调试起来也易懂一点。</p><ul><li><strong>状态逻辑难复用</strong>：</li></ul><p> 在组件之间复用状态逻辑很难，可能要用到 <strong>render props</strong> （渲染属性）或者 <strong>HOC</strong>（高阶组件），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），导致层级冗余。</p><h2 id="2-Hooks带来的好处"><a href="#2-Hooks带来的好处" class="headerlink" title="2. Hooks带来的好处"></a>2. Hooks带来的好处</h2><ul><li>逻辑复用</li></ul><p>在组件之前复用状态逻辑，往往需要借助高阶组件等复杂的设计模式，这些高级组件会产生冗余的组件节点，让调试变得困难，下面用一个demo来对比一下两种实现方式。</p><blockquote><p>Class</p></blockquote><p>在class组件场景下，定义了一个高阶组件，负责监听窗口大小变化，并将变化后的值作为 props 传给下一个组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> useWindowSize = <span class="hljs-function"><span class="hljs-params">Component</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 产生一个高阶组件 HOC，只包含监听窗口大小的逻辑</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HOC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>      <span class="hljs-built_in">super</span>(props);<br>      <span class="hljs-built_in">this</span>.state = &#123;<br>        <span class="hljs-attr">size</span>: <span class="hljs-built_in">this</span>.getSize()<br>      &#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-built_in">this</span>.handleResize); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-built_in">this</span>.handleResize);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">getSize</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.innerWidth &gt; <span class="hljs-number">1000</span> ? <span class="hljs-string">&quot;large&quot;</span> ：<span class="hljs-string">&quot;small&quot;</span>;<br>    &#125;<br>    handleResize = <span class="hljs-function">()=&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> currentSize = <span class="hljs-built_in">this</span>.getSize();<br>      <span class="hljs-built_in">this</span>.setState(&#123;<br>        <span class="hljs-attr">size</span>: <span class="hljs-built_in">this</span>.getSize()<br>      &#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-comment">// 将窗口大小传递给真正的业务逻辑组件</span><br>      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;this.state.size&#125;</span> /&gt;</span></span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> HOC;<br>&#125;;<br></code></pre></td></tr></table></figure><p>接下来可以在自定义组件中可以调用 useWindowSize 这样的函数来产生一个新组件，并自带 size 属性，例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br>  render() &#123;<br>    const &#123; size &#125; = <span class="hljs-keyword">this</span>.props;<br>    <span class="hljs-keyword">if</span> (size === <span class="hljs-string">&quot;small&quot;</span>) <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">SmallComponent</span> /&gt;;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">LargeComponent</span> /&gt;;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 使用 useWindowSize 产生高阶组件，用于产生 size 属性传递给真正的业务组件</span><br>export <span class="hljs-keyword">default</span> useWindowSize(<span class="hljs-type">MyComponent</span>); <br></code></pre></td></tr></table></figure><p>下面看下Hooks的实现方式</p><blockquote><p>Hooks</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const getSize = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.innerWidth &gt; <span class="hljs-number">1000</span> ? <span class="hljs-string">&quot;large&quot;</span> : <span class="hljs-string">&quot;small&quot;</span>;<br>&#125;<br>const useWindowSize = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  const [size, setSize] = useState(getSize());<br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  const handler = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      setSize(getSize())<br>    &#125;;<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, handler);<br>    <span class="hljs-keyword">return</span> () =&gt; &#123;<br>      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, handler);<br>    &#125;;<br>  &#125;, []);<br>  <br>  <span class="hljs-keyword">return</span> size;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Demo = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> size = useWindowSize();<br>  <span class="hljs-keyword">if</span> (size === <span class="hljs-string">&quot;small&quot;</span>) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SmallComponent</span> /&gt;</span></span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LargeComponent</span> /&gt;</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从上面的例子中通过 Hooks 的方式对窗口大小进行了封装，从而将其变成一个可绑定的数据源。这样当窗口大小发生变化时，使用这个 Hook 的组件就都会重新渲染。而且代码也更加简洁和直观，不会产生额外的组件节点，也不显得那么冗余了。</p><ul><li>业务代码更加聚合</li></ul><p>下面举一个最常见的计时器的例子。</p><blockquote><p>class</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br><span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearInterval</span>(timer)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Hooks</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    let timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (timer) clearInterval(timer)<br>    &#125;<br>&#125;, [<span class="hljs-comment">//...])</span><br></code></pre></td></tr></table></figure><p>Hooks的实现方式能让代码更加集中，逻辑也更清晰。</p><ul><li>写法简洁</li></ul><p>这个就不举例了，可以从字面意思理解，使用函数组件确实能少些很多代码，懂得都懂，嘻嘻~</p><h1 id="几个内置Hooks的作用以及使用思考"><a href="#几个内置Hooks的作用以及使用思考" class="headerlink" title="几个内置Hooks的作用以及使用思考"></a>几个内置Hooks的作用以及使用思考</h1><h2 id="useState：让函数组件具有维持状态的能力"><a href="#useState：让函数组件具有维持状态的能力" class="headerlink" title="useState：让函数组件具有维持状态的能力"></a>useState：让函数组件具有维持状态的能力</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">count</span>, setCount] = useState(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p><strong>让函数组件具有维持状态的能力</strong>，即：在一个函数组件的多次渲染之间，这个 state 是<strong>共享</strong>的。便于维护状态。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p><strong>一旦组件有自己状态，意味着组件如果重新创建，就需要有恢复状态的过程，这通常会让组件变得更复杂。</strong></p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><ol><li>useState(initialState) 的参数 initialState 是创建 state 的初始值。</li></ol><blockquote><p>它可以是任意类型，比如数字、对象、数组等等。</p></blockquote><ol start="2"><li>useState() 的返回值是一个有着两个元素的数组。第一个数组元素用来读取 state 的值，第二个则是用来设置这个 state 的值。</li></ol><blockquote><p>在这里要注意的是，state 的变量（例子中的 count）是只读的，所以我们必须通过第二个数组元素 setCount 来设置它的值。</p></blockquote><ol start="3"><li>如果要创建多个 <strong>state</strong>，那么我们就需要多次调用 useState。</li></ol><h3 id="什么样的值应该保存在-state-中？"><a href="#什么样的值应该保存在-state-中？" class="headerlink" title="什么样的值应该保存在 state 中？"></a>什么样的值应该保存在 state 中？</h3><p>通常来说，我们要遵循的一个原则就是：<strong>state 中不要保存可以通过计算得到的值</strong>。</p><ul><li><p>从 props 传递过来的值。有时候 props 传递过来的值无法直接使用，而是要通过一定的计算后再在 UI 上展示，比如说排序。那么我们要做的就是每次用的时候，都重新排序一下，或者利用某些 cache 机制，而不是将结果直接放到 state 里。</p></li><li><p>从 URL 中读到的值。比如有时需要读取 URL 中的参数，把它作为组件的一部分状态。那么我们可以在每次需要用的时候从 URL 中读取，而不是读出来直接放到 state 里。</p></li><li><p>从 cookie、localStorage 中读取的值。通常来说，也是每次要用的时候直接去读取，而不是读出来后放到 state 里。</p></li></ul><h2 id="useEffect：执行副作用"><a href="#useEffect：执行副作用" class="headerlink" title="useEffect：执行副作用"></a>useEffect：执行副作用</h2><blockquote><p>useEffect(fn, deps);</p></blockquote><p>useEffect ，顾名思义，用于执行一段副作用。</p><h3 id="什么是副作用？"><a href="#什么是副作用？" class="headerlink" title="什么是副作用？"></a>什么是副作用？</h3><p>通常来说，副作用是指一段和当前执行结果无关的代码。比如说要修改函数外部的某个变量，要发起一个请求，等等。</p><p>也就是说，在函数组件的当次执行过程中，<strong>useEffect 中代码的执行是不影响渲染出来的 UI</strong>的。</p><p>对应到 Class 组件，那么 useEffect 就涵盖了 ComponentDidMount、componentDidUpdate 和 componentWillUnmount 三个生命周期方法。不过如果你习惯了使用 Class 组件，那千万不要按照把 useEffect 对应到某个或者某几个生命周期的方法。你只要记住，useEffect 是每次组件 render 完后判断依赖并执行就可以了。</p><p>useEffect 还有两个特殊的用法：没有依赖项，以及依赖项作为空数组。我们来具体分析下。</p><ol><li>没有依赖项，则每次 render 后都会重新执行。例如：</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> 每次 render 完一定执行<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;渲染...........&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li>空数组作为依赖项，则只在首次执行时触发，对应到 Class 组件就是 componentDidMount。例如：</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> 组件首次渲染时执行，等价于 <span class="hljs-class"><span class="hljs-keyword">class</span> 组件中的 <span class="hljs-title">componentDidMount</span></span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;did mount........&#x27;</span>);<br>&#125;, []);<br></code></pre></td></tr></table></figure><h3 id="小结用法"><a href="#小结用法" class="headerlink" title="小结用法:"></a>小结用法:</h3><p>总结一下，useEffect 让我们能够在下面四种时机去执行一个回调函数产生副作用：</p><ol><li>每次 render 后执行：不提供第二个依赖项参数。</li></ol><blockquote><p>比如useEffect(() =&gt; {})。</p></blockquote><ol start="2"><li>仅第一次 render 后执行：提供一个空数组作为依赖项。</li></ol><blockquote><p>比如useEffect(() =&gt; {}, [])。</p></blockquote><ol start="3"><li>第一次以及依赖项发生变化后执行：提供依赖项数组。</li></ol><blockquote><p>比如useEffect(() =&gt; {}, [deps])。</p></blockquote><ol start="4"><li>组件 unmount 后执行：返回一个回调函数。</li></ol><blockquote><p>比如useEffect() =&gt; { return () =&gt; {} }, [])。</p></blockquote><h2 id="useCallback：缓存回调函数"><a href="#useCallback：缓存回调函数" class="headerlink" title="useCallback：缓存回调函数"></a>useCallback：缓存回调函数</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">Callback(<span class="hljs-params">fn</span>, <span class="hljs-params">deps</span>)</span><br></code></pre></td></tr></table></figure><h3 id="为什么要使用useCallback"><a href="#为什么要使用useCallback" class="headerlink" title="为什么要使用useCallback?"></a>为什么要使用useCallback?</h3><p>在 React 函数组件中，<strong>每一次 UI 的变化，都是通过重新执行整个函数来完成的</strong>，这和传统的 Class 组件有很大区别：函数组件中并没有一个直接的方式在多次渲染之间维持一个状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-function">() =&gt;</span> setCount(count+<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleIncrement&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>思考下这个过程。<strong>每次组件状态发生变化的时候，函数组件实际上都会重新执行一遍</strong>。在每次执行的时候，实际上都会创建一个新的事件处理函数 <strong>handleIncrement</strong>。</p><p>这也意味着，即使 count 没有发生变化，但是函数组件因为其它状态发生变化而重新渲染时（函数组件重新被执行），这种写法也会每次创建一个新的函数。创建一个新的事件处理函数，虽然不影响结果的正确性，但其实是没必要的。因为这样做不仅增加了系统的开销，更重要的是：<strong>每次创建新函数的方式会让接收事件处理函数的组件，需要重新渲染</strong>。</p><p>比如这个例子中的 button 组件，接收了 handleIncrement ，并作为一个属性。如果每次都是一个新的，那么这个 React 就会认为这个组件的 props 发生了变化，从而必须重新渲染。因此，我们需要做到的是：<strong>只有当 count 发生变化时，我们才需要重新定一个回调函数</strong>。而这正是 useCallback 这个 Hook 的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> handleIncrement = useCallback(<br>    <span class="hljs-function">() =&gt;</span> setCount(count + <span class="hljs-number">1</span>),<br>    [count], <span class="hljs-comment">// 只有当 count 发生变化时，才会重新创建回调函数</span><br>  );<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleIncrement&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="useMemo：缓存计算的结果"><a href="#useMemo：缓存计算的结果" class="headerlink" title="useMemo：缓存计算的结果"></a>useMemo：缓存计算的结果</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">use<span class="hljs-constructor">Memo(<span class="hljs-params">fn</span>, <span class="hljs-params">deps</span>)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)。</p></blockquote><p>这里的 fn 是产生所需数据的一个<strong>计算函数</strong>。通常来说，<strong>fn 会使用 deps 中声明的一些变量来生成一个结果，用来渲染出最终的 UI</strong>。</p><p>这个场景应该很容易理解：如果某个<strong>数据</strong>是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算。</p><h3 id="避免重复计算"><a href="#避免重复计算" class="headerlink" title="避免重复计算"></a>避免重复计算</h3><blockquote><p>通过 <strong>useMemo</strong> 这个 Hook，可以避免在用到的数据没发生变化时进行的重复计算。虽然例子展示的是一个很简单的场景，但如果是一个复杂的计算，那么对于<strong>提升性能</strong>会有很大的帮助。</p></blockquote><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> calc = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 假设这里做了复杂的计算，暂时用次幂模拟</span><br>    <span class="hljs-keyword">return</span> a ** b;<br>&#125;<br><span class="hljs-keyword">const</span> MyComponent = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;a, b&#125; = props;<br>    <span class="hljs-keyword">const</span> c = calc(a, b);<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>c: &#123;c&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 calc 计算耗时 1000ms，那么每次渲染都要等待这么久，怎么优化呢？</p><blockquote><p>a, b 值不变的情况下，得出的 c 定是相同的。</p></blockquote><p>所以我们可以用 useMemo 把值给缓存起来，避免重复计算相同的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> calc = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 假设这里做了复杂的计算，暂时用次幂模拟</span><br>    <span class="hljs-keyword">return</span> a ** b;<br>&#125;<br><span class="hljs-keyword">const</span> MyComponent = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;a, b&#125; = props;<br>    <span class="hljs-comment">// 缓存</span><br>    <span class="hljs-keyword">const</span> c = React.useMemo(<span class="hljs-function">() =&gt;</span> calc(a, b), [a, b]);<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>c: &#123;c&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>useCallback 的功能其实是可以用 useMemo 来实现的:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const myEventHandler = useMemo(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 返回一个函数作为缓存结果</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在这里进行事件处理</span><br>  &#125;<br>&#125;, [dep1, dep2]);<br></code></pre></td></tr></table></figure><h3 id="小结一下："><a href="#小结一下：" class="headerlink" title="小结一下："></a>小结一下：</h3><p><strong>感觉到这有这种感觉，其实hook就是建立了一个绑定某个结果到依赖数据的关系。只有当依赖变了，这个结果才需要被重新得到。</strong></p><h2 id="useRef：在多次渲染之间共享数据"><a href="#useRef：在多次渲染之间共享数据" class="headerlink" title="useRef：在多次渲染之间共享数据"></a>useRef：在多次渲染之间共享数据</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const myRefContainer</span> = useRef(initialValue);<br></code></pre></td></tr></table></figure><p>我们可以把 <strong>useRef</strong> 看作是在函数组件之外创建的一个容器空间。在这个容器上，我们可以通过唯一的 current 属设置一个值，从而在函数组件的多次渲染之间共享这个值。</p><h3 id="useRef-的重要的功能"><a href="#useRef-的重要的功能" class="headerlink" title="useRef 的重要的功能"></a>useRef 的重要的功能</h3><h4 id="1-存储跨渲染的数据"><a href="#1-存储跨渲染的数据" class="headerlink" title="1. 存储跨渲染的数据"></a>1. 存储跨渲染的数据</h4><p>使用 <strong>useRef</strong> 保存的数据一般是和 UI 的渲染无关的，因此当 <strong>ref</strong> 的值发生变化时，是不会触发组件的重新渲染的，这也是 <strong>useRef</strong> 区别于 <strong>useState</strong> 的地方。</p><p>举例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const [time, setTime] = useState(<span class="hljs-number">0</span>);<br><span class="hljs-regexp">//</span> 定义 timer 这样一个容器用于在跨组件渲染之间保存一个变量 <br>const timer = useRef(<span class="hljs-literal">null</span>);<br><br> const handleStart = useCallback(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-regexp">//</span> 使用 current 属性设置 ref 的值<br>   timer.current = <span class="hljs-built_in">window</span>.<span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; setTime(<span class="hljs-function"><span class="hljs-params">(time)</span> =&gt;</span> time + <span class="hljs-number">1</span>); &#125;, <span class="hljs-number">100</span>);<br> &#125;, []);<br></code></pre></td></tr></table></figure><h4 id="2-保存某个-DOM-节点的引用"><a href="#2-保存某个-DOM-节点的引用" class="headerlink" title="2. 保存某个 DOM 节点的引用"></a>2. 保存某个 DOM 节点的引用</h4><blockquote><p>是在某些场景中，我们必须要获得真实<strong>DOM</strong>节点的引用，所以结合 React 的 <strong>ref</strong> 属性和 <strong>useRef</strong> 这个 Hook，我们就可以获得真实的 DOM 节点，并对这个节点进行操作。</p></blockquote><p>React 官方例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> inputEl = useRef(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// current 属性指向了真实的 input 这个 DOM 节点，从而可以调用 focus 方法</span><br>    inputEl.current.focus();<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputEl&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h4><p>可以看到ref 这个属性提供了获得 DOM 节点的能力，并利用 useRef 保存了这个节点的应用。这样的话，一旦 input 节点被渲染到界面上，那我们通过 inputEl.current 就能访问到真实的 DOM 节点的实例了</p><h2 id="useContext：定义全局状态"><a href="#useContext：定义全局状态" class="headerlink" title="useContext：定义全局状态"></a>useContext：定义全局状态</h2><h3 id="为什么要使用-useContext？"><a href="#为什么要使用-useContext？" class="headerlink" title="为什么要使用 useContext？"></a>为什么要使用 useContext？</h3><p>React 组件之间的状态传递只有一种方式，那就是通过 props。缺点：<strong>这种传递关系只能在父子组件之间进行。</strong></p><p>那么问题出现：跨层次，或者同层的组件之间要如何进行数据的共享？这就涉及到一个新的命题：<strong>全局状态管理</strong>。</p><p>果：react提供的解决方案：<strong>Context</strong> 机制。</p><h3 id="具体原理："><a href="#具体原理：" class="headerlink" title="具体原理："></a>具体原理：</h3><p>React 提供了 Context 这样一个机制，<strong>能够让所有在某个组件开始的组件树上创建一个 Context。这样这个组件树上的所有组件，就都能访问和修改这个 Context</strong> 了。</p><p>那么在函数组件里，我们就可以使用 useContext 这样一个 Hook 来管理 Context。</p><h3 id="使用：（这儿用了官方例子）"><a href="#使用：（这儿用了官方例子）" class="headerlink" title="使用：（这儿用了官方例子）"></a>使用：（这儿用了官方例子）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">const</span> themes = &#123;<br>  <span class="hljs-attr">light</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;#eeeeee&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">dark</span>: &#123;<br>    <span class="hljs-attr">foreground</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>,<br>    <span class="hljs-attr">background</span>: <span class="hljs-string">&quot;#222222&quot;</span><br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 创建一个 Theme 的 Context</span><br><br><span class="hljs-keyword">const</span> ThemeContext = React.createContext(themes.light);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 整个应用使用 ThemeContext.Provider 作为根组件</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-comment">// 使用 themes.dark 作为当前 Context </span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;themes.dark&#125;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Toolbar</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 在 Toolbar 组件中使用一个会使用 Theme 的 Button</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Toolbar</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ThemedButton</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-comment">// 在 Theme Button 中使用 useContext 来获取当前的主题</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ThemedButton</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> theme = useContext(ThemeContext);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">background:</span> <span class="hljs-attr">theme.background</span>,</span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">color:</span> <span class="hljs-attr">theme.foreground</span></span></span><br><span class="hljs-tag"><span class="xml">    &#125;&#125;&gt;</span></span><br><span class="xml">      I am styled by theme context!</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><p><strong>Context</strong> 提供了一个方便在多个组件之间共享数据的机制。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><p>Context 相当于提供了一个定义 React 世界中全局变量的机制，而全局变量则意味着两点：</p><h4 id="1-会让调试变得困难，因为你很难跟踪某个-Context-的变化究竟是如何产生的。"><a href="#1-会让调试变得困难，因为你很难跟踪某个-Context-的变化究竟是如何产生的。" class="headerlink" title="1. 会让调试变得困难，因为你很难跟踪某个 Context 的变化究竟是如何产生的。"></a>1. 会让调试变得困难，因为你很难跟踪某个 Context 的变化究竟是如何产生的。</h4><h4 id="2-让组件的复用变得困难，因为一个组件如果使用了某个-Context，它就必须确保被用到的地方一定有这个-Context-的-Provider-在其父组件的路径上。"><a href="#2-让组件的复用变得困难，因为一个组件如果使用了某个-Context，它就必须确保被用到的地方一定有这个-Context-的-Provider-在其父组件的路径上。" class="headerlink" title="2. 让组件的复用变得困难，因为一个组件如果使用了某个 Context，它就必须确保被用到的地方一定有这个 Context 的 Provider 在其父组件的路径上。"></a>2. 让组件的复用变得困难，因为一个组件如果使用了某个 Context，它就必须确保被用到的地方一定有这个 Context 的 Provider 在其父组件的路径上。</h4><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p>由于以上缺点，所以在 React 的开发中，除了像 Theme、Language 等一目了然的需要全局设置的变量外（my: 只读取，不需要在项目里手动触发修改的），我们很少会使用 Context 来做太多数据的共享。需要再三强调的是，Context 更多的是提供了一个强大的机制，让 React 应用具备定义全局的响应式数据的能力。</p><blockquote><p>此外，很多状态管理框架，比如 Redux，正是利用了 Context 的机制来提供一种更加可控的组件之间的状态管理机制。因此，理解 Context 的机制，也可以让我们更好地去理解 Redux 这样的框架实现的原理。</p></blockquote><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>感觉这次的内容不多不少。其实了解学会了useState 和 useEffect 这两个 核心 Hooks，几乎就能完成所有 React 功能的开发了。</p><p>useCallback、useMemo、useRef 和 useContext。这几个 Hook 都是为了解决函数组件中遇到的特定问题。</p><p>还有几个比较边缘的hook这里就不再写了，有兴趣的大佬可以移步到官方文档上看看。</p><p>码字不易，也辛苦大佬们抽空了解了~</p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>农民工日记04</title>
    <link href="/2021/11/10/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B004/"/>
    <url>/2021/11/10/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B004/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近发现一个问题，感觉自己懂，但是说不出来，其实还是没那么明白，起码得试着先给自己讲明白。</p><h3 id="React篇"><a href="#React篇" class="headerlink" title="React篇"></a>React篇</h3><ol><li>React之setState原理分析</li></ol><p><a href="http://blog.poetries.top/2018/12/20/react-setState/">http://blog.poetries.top/2018/12/20/react-setState/</a></p><ol start="2"><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重构总结</title>
    <link href="/2021/11/03/%E9%87%8D%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <url>/2021/11/03/%E9%87%8D%E6%9E%84%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>项目得多做总结，能记就记一下。</p><h2 id="从打包开始"><a href="#从打包开始" class="headerlink" title="从打包开始"></a>从打包开始</h2><p>package.json =&gt; scripts</p><p>找到运行脚本 =&gt; 在根目录下scripts/start.js</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;app&quot;</span>: <span class="hljs-string">&quot;npm run api &amp;&amp; npm run start&quot;</span>,<br>  <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;node scripts/start.js&quot;</span>,<br>  <span class="hljs-string">...</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>查看start.js</p><p>大多数都是一些执行脚本，并且目前大多数项目都是使用的Webpack打包，这里稍微记录一下setupProxy（转发代理）</p><h2 id="介绍一下项目结构，可以以此为参考"><a href="#介绍一下项目结构，可以以此为参考" class="headerlink" title="介绍一下项目结构，可以以此为参考"></a>介绍一下项目结构，可以以此为参考</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">.<br>├── README.md<br>├── <span class="hljs-built_in">config</span>                 <span class="hljs-comment"># 配置文件</span><br>├── mock                   <span class="hljs-comment"># 模拟数据</span><br>├── package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span>├── public                 <span class="hljs-comment"># 公共资源</span><br>├── <span class="hljs-keyword">scripts </span>               <span class="hljs-comment"># 构建脚本</span><br>└── src<br>    ├── assets             <span class="hljs-comment"># 静态资源</span><br>    ├── components         <span class="hljs-comment"># 公共组件</span><br>    ├── configs            <span class="hljs-comment"># 配置文件</span><br>    ├── layouts            <span class="hljs-comment"># 布局组件</span><br>    ├── models             <span class="hljs-comment"># 数据模型</span><br>    ├── pages              <span class="hljs-comment"># 页面组件</span><br>    ├── services           <span class="hljs-comment"># 接口服务</span><br>    ├── styles             <span class="hljs-comment"># 全局样式</span><br>    ├── utils              <span class="hljs-comment"># 工具函数</span><br>    └── index.tsx          <span class="hljs-comment"># 入口文件</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可拖拽的List组件</title>
    <link href="/2021/11/03/%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%9A%84List%E7%BB%84%E4%BB%B6/"/>
    <url>/2021/11/03/%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%9A%84List%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本组件是基于react-beautiful-dnd包封装的可拖拽的List组件。</p><h3 id="关键代码如下："><a href="#关键代码如下：" class="headerlink" title="关键代码如下："></a>关键代码如下：</h3><p>App.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; list &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./const&quot;</span>;<br><span class="hljs-keyword">import</span> DraggableList <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./DraggableList&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span>;<br><br><span class="hljs-keyword">const</span> renderListItem = <span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; name &#125; = item;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [data, onDragEnd] = useState(list);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DraggableList</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">list</span>=<span class="hljs-string">&#123;data&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">listItemKey</span>=<span class="hljs-string">&quot;id&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">renderListItem</span>=<span class="hljs-string">&#123;renderListItem&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">onDragEnd</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> onDragEnd(e)&#125;</span><br><span class="xml">      /&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>DraggableList.tsx</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* eslint-disable react/prop-types */</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; DragDropContext, Droppable, Draggable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-beautiful-dnd&quot;</span>;<br><br><span class="hljs-comment">// a little function to help us with reordering the result</span><br><span class="hljs-keyword">const</span> reorder = <span class="hljs-function">(<span class="hljs-params">list: <span class="hljs-built_in">any</span>, startIndex: <span class="hljs-built_in">any</span>, endIndex: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Array</span>.from(list);<br>  <span class="hljs-keyword">const</span> [removed] = result.splice(startIndex, <span class="hljs-number">1</span>);<br>  result.splice(endIndex, <span class="hljs-number">0</span>, removed);<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-keyword">const</span> getItemStyle = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  isDragging: <span class="hljs-built_in">boolean</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  draggableStyle: <span class="hljs-built_in">any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  height: <span class="hljs-built_in">any</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  margin = <span class="hljs-string">&quot;1px&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> (&#123;<br>  <span class="hljs-comment">// some basic styles to make the items look a bit nicer</span><br>  <span class="hljs-attr">padding</span>: <span class="hljs-string">&quot;0 12px&quot;</span>,<br>  <span class="hljs-attr">userSelect</span>: <span class="hljs-string">&quot;none&quot;</span>,<br>  height,<br>  margin,<br>  <span class="hljs-attr">border</span>: <span class="hljs-string">&quot;1px solid #d9d9d9&quot;</span>,<br><br>  <span class="hljs-comment">// change background colour if dragging</span><br>  <span class="hljs-attr">background</span>: isDragging ? <span class="hljs-string">&quot;#69c0ff&quot;</span> : <span class="hljs-string">&quot;white&quot;</span>,<br><br>  <span class="hljs-comment">// styles we need to apply on draggables</span><br>  ...draggableStyle<br>&#125;);<br><br><span class="hljs-keyword">const</span> getListStyle = <span class="hljs-function">(<span class="hljs-params">isDraggingOver: <span class="hljs-built_in">any</span></span>) =&gt;</span> (&#123;<br>  <span class="hljs-attr">background</span>: isDraggingOver ? <span class="hljs-string">&quot;#e6f7fe&quot;</span> : <span class="hljs-string">&quot;white&quot;</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;100%&quot;</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DraggableList</span>(<span class="hljs-params">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  list,</span></span><br><span class="hljs-params"><span class="hljs-function">  listItemKey,</span></span><br><span class="hljs-params"><span class="hljs-function">  renderListItem,</span></span><br><span class="hljs-params"><span class="hljs-function">  onDragEnd,</span></span><br><span class="hljs-params"><span class="hljs-function">  itemHeight = <span class="hljs-string">&quot;51px&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  margin</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DragDropContext</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">onDragEnd</span>=<span class="hljs-string">&#123;(result:</span> <span class="hljs-attr">any</span>) =&gt;</span> &#123;</span><br><span class="xml">        console.log(&quot;result&quot;, result);</span><br><span class="xml">        if (!result.destination) return;</span><br><span class="xml">        const orderedList = reorder(</span><br><span class="xml">          list,</span><br><span class="xml">          result.source.index,</span><br><span class="xml">          result.destination.index</span><br><span class="xml">        );</span><br><span class="xml">        if (onDragEnd) onDragEnd(orderedList);</span><br><span class="xml">      &#125;&#125;</span><br><span class="xml">    &gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Droppable</span> <span class="hljs-attr">droppableId</span>=<span class="hljs-string">&quot;droppable&quot;</span>&gt;</span></span><br><span class="xml">        &#123;(provided, snapshot) =&gt; (</span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="xml">            &#123;<span class="hljs-attr">...provided.droppableProps</span>&#125;</span></span><br><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;provided.innerRef&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;getListStyle(snapshot.isDraggingOver)&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">          &gt;</span></span><br><span class="xml">            &#123;list.map((item: any, index: any) =&gt; &#123;</span><br><span class="xml">              const key = listItemKey ? item[listItemKey] : index;</span><br><span class="xml"></span><br><span class="xml">              return (</span><br><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Draggable</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;key&#125;</span> <span class="hljs-attr">draggableId</span>=<span class="hljs-string">&#123;</span>`$&#123;<span class="hljs-attr">key</span>&#125;`&#125; <span class="hljs-attr">index</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span></span><br><span class="xml">                  &#123;(provided, snapshot) =&gt; (</span><br><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="xml">                      <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;provided.innerRef&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">                      &#123;<span class="hljs-attr">...provided.draggableProps</span>&#125;</span></span><br><span class="hljs-tag"><span class="xml">                      &#123;<span class="hljs-attr">...provided.dragHandleProps</span>&#125;</span></span><br><span class="hljs-tag"><span class="xml">                      <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;getItemStyle(</span></span></span><br><span class="hljs-tag"><span class="xml">                        <span class="hljs-attr">snapshot.isDragging</span>,</span></span><br><span class="hljs-tag"><span class="xml">                        <span class="hljs-attr">provided.draggableProps.style</span>,</span></span><br><span class="hljs-tag"><span class="xml">                        <span class="hljs-attr">itemHeight</span>,</span></span><br><span class="hljs-tag"><span class="xml">                        <span class="hljs-attr">margin</span></span></span><br><span class="hljs-tag"><span class="xml">                      )&#125;</span></span><br><span class="hljs-tag"><span class="xml">                    &gt;</span></span><br><span class="xml">                      &#123;renderListItem(item, index)&#125;</span><br><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                  )&#125;</span><br><span class="xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">Draggable</span>&gt;</span></span><br><span class="xml">              );</span><br><span class="xml">            &#125;)&#125;</span><br><span class="xml">            &#123;provided.placeholder&#125;</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        )&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Droppable</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">DragDropContext</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>演示地址：<br><a href="https://codesandbox.io/s/draggablelist-ot1n7?file=/src/App.js:0-558">这里</a>是本节的全部代码</p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三级级联选择器</title>
    <link href="/2021/10/28/%E4%B8%89%E7%BA%A7%E7%BA%A7%E8%81%94Select/"/>
    <url>/2021/10/28/%E4%B8%89%E7%BA%A7%E7%BA%A7%E8%81%94Select/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本组件是基于antd4.x的Select组件，二次封装的三级级联选择器，用法：将数据按照规定的格式传入为组件的props，即可完成选择。</p><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><p>DiSelect3Cas.tsx</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author <span class="hljs-variable">zhangzheyi</span></span></span><br><span class="hljs-comment"> * 3级联动的选择器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Select &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><br><span class="hljs-keyword">const</span> &#123; Option &#125; = Select;<br><span class="hljs-keyword">const</span> stPre = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-attr">display</span>: <span class="hljs-string">&quot;inline-block&quot;</span>, <span class="hljs-attr">verticalAlign</span>: <span class="hljs-string">&quot;top&quot;</span> &#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DiSelect3Cas</span>(<span class="hljs-params">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  pre,</span></span><br><span class="hljs-params"><span class="hljs-function">  required,</span></span><br><span class="hljs-params"><span class="hljs-function">  block,</span></span><br><span class="hljs-params"><span class="hljs-function">  title,</span></span><br><span class="hljs-params"><span class="hljs-function">  value = [],</span></span><br><span class="hljs-params"><span class="hljs-function">  onChange,</span></span><br><span class="hljs-params"><span class="hljs-function">  data = [],</span></span><br><span class="hljs-params"><span class="hljs-function">  hasEmpty,</span></span><br><span class="hljs-params"><span class="hljs-function">  emptyLabel = <span class="hljs-string">&quot;不限&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  emptyValue = <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  extraStyle = &#123;&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;: DiSelect3</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> style = &#123; <span class="hljs-attr">display</span>: <span class="hljs-string">&quot;inline-block&quot;</span> &#125;;<br>  <span class="hljs-keyword">if</span> (block) style.display = <span class="hljs-string">&quot;block&quot;</span>;<br>  <span class="hljs-keyword">const</span> preView = pre ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;stPre&#125;</span>&gt;</span>&#123;required ? &quot;* &quot; : &quot;  &quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span></span> : <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-attr">title</span>: titleSt = &#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;80px&quot;</span>, <span class="hljs-attr">fontWeight</span>: <span class="hljs-number">500</span> &#125;,<br>    <span class="hljs-attr">input</span>: inputSt = &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">120</span> &#125;<br>  &#125; = extraStyle;<br>  <span class="hljs-keyword">const</span> [data0 = [], data1 = [], data2 = []] = data;<br>  <span class="hljs-keyword">const</span> [value0, value1, value2] = value;<br><br>  <span class="hljs-keyword">const</span> onSelectChange = <span class="hljs-function">(<span class="hljs-params">selectorIdx: <span class="hljs-built_in">number</span>, value: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (onChange) &#123;<br>      <span class="hljs-keyword">const</span> passedValue = [value0, value1, value2];<br>      passedValue[selectorIdx] = value;<br>      <span class="hljs-keyword">if</span> (selectorIdx === <span class="hljs-number">0</span>) &#123;<br>        passedValue[<span class="hljs-number">1</span>] = emptyValue;<br>        passedValue[<span class="hljs-number">2</span>] = emptyValue;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectorIdx === <span class="hljs-number">1</span>) &#123;<br>        passedValue[<span class="hljs-number">2</span>] = emptyValue;<br>      &#125;<br>      onChange(passedValue);<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;difilter-item-wrap&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span>&gt;</span></span><br><span class="xml">      &#123;preView&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;func-title&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;titleSt&#125;</span>&gt;</span></span><br><span class="xml">        &#123;title&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Select</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value0&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">small</span>&quot;&#125;</span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;inputSt&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(value)</span> =&gt;</span> onSelectChange(0, value)&#125;</span><br><span class="xml">      &gt;</span><br><span class="xml">        &#123;hasEmpty ? (</span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;__hasEmpty__&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;emptyValue&#125;</span>&gt;</span></span><br><span class="xml">            &#123;emptyLabel&#125;</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Option</span>&gt;</span></span><br><span class="xml">        ) : (</span><br><span class="xml">          &quot;&quot;</span><br><span class="xml">        )&#125;</span><br><span class="xml">        &#123;data0.map((v: any, i: any) =&gt; (</span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i&#125;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;v.value&#125;</span>&gt;</span></span><br><span class="xml">            &#123;v.label&#125;</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Option</span>&gt;</span></span><br><span class="xml">        ))&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Select</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Select</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value1&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">small</span>&quot;&#125;</span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;inputSt&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(value)</span> =&gt;</span> onSelectChange(1, value)&#125;</span><br><span class="xml">      &gt;</span><br><span class="xml">        &#123;hasEmpty ? (</span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;__hasEmpty__&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;emptyValue&#125;</span>&gt;</span></span><br><span class="xml">            &#123;emptyLabel&#125;</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Option</span>&gt;</span></span><br><span class="xml">        ) : (</span><br><span class="xml">          &quot;&quot;</span><br><span class="xml">        )&#125;</span><br><span class="xml">        &#123;data1.map((v: any, i: any) =&gt; (</span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i&#125;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;v.value&#125;</span>&gt;</span></span><br><span class="xml">            &#123;v.label&#125;</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Option</span>&gt;</span></span><br><span class="xml">        ))&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Select</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Select</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value2&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">size</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">small</span>&quot;&#125;</span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;inputSt&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(value)</span> =&gt;</span> onSelectChange(2, value)&#125;</span><br><span class="xml">      &gt;</span><br><span class="xml">        &#123;hasEmpty ? (</span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;__hasEmpty__&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;emptyValue&#125;</span>&gt;</span></span><br><span class="xml">            &#123;emptyLabel&#125;</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Option</span>&gt;</span></span><br><span class="xml">        ) : (</span><br><span class="xml">          &quot;&quot;</span><br><span class="xml">        )&#125;</span><br><span class="xml">        &#123;data2.map((v: any, i: any) =&gt; (</span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Option</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i&#125;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;v.value&#125;</span>&gt;</span></span><br><span class="xml">            &#123;v.label&#125;</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">Option</span>&gt;</span></span><br><span class="xml">        ))&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Select</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">interface</span> DiSelect3 &#123;<br>  <span class="hljs-attr">pre</span>: <span class="hljs-built_in">boolean</span>;<br>  required: <span class="hljs-built_in">boolean</span>;<br>  block: <span class="hljs-built_in">boolean</span>;<br>  title: <span class="hljs-built_in">string</span>;<br>  value: <span class="hljs-built_in">string</span>[];<br>  data: <span class="hljs-built_in">any</span>;<br>  hasEmpty: <span class="hljs-built_in">boolean</span>;<br>  emptyLabel: <span class="hljs-built_in">string</span>;<br>  emptyValue: <span class="hljs-built_in">string</span>;<br>  extraStyle: &#123;<br>    title?: &#123;&#125;;<br>    input?: &#123;&#125;;<br>  &#125;;<br>  onChange: <span class="hljs-built_in">any</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>App.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> DiSelect3Cas <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./DiSelect3Cas&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; data &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./const&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>data 原始数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>cateForUi 默认值为[&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;], 三个字符串分表代表一二三级级联的id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computed</span>(<span class="hljs-params">data, cateForUi</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [value0, value1] = cateForUi;<br>  <span class="hljs-keyword">return</span> [data[<span class="hljs-number">0</span>], data[<span class="hljs-number">1</span>][value0] || [], data[<span class="hljs-number">2</span>][value1] || []];<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [cateForUi, changeUI] = useState([<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">DiSelect3Cas</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;computed(data,</span> <span class="hljs-attr">cateForUi</span>)&#125;</span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;所属行业&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">hasEmpty</span>=<span class="hljs-string">&#123;true&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">emptyLabel</span>=<span class="hljs-string">&quot;请选择&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> changeUI(e)&#125;</span><br><span class="xml">        value=&#123;cateForUi&#125;</span><br><span class="xml">      /&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>具体演示地址在<a href="https://codesandbox.io/s/diselectcas-pb8on?file=/src/App.js:0-720">https://codesandbox.io/s/diselectcas-pb8on?file=/src/App.js:0-720</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>组件</tag>
      
      <tag>antd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js一些语法小技巧</title>
    <link href="/2021/10/27/js%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/10/27/js%E4%B8%80%E4%BA%9B%E8%AF%AD%E6%B3%95%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>有空还是得看看大佬写的代码，有的语法和小技巧可以借鉴一下，确实能提高不少效率。</p><h2 id="1-js双叹号的作用"><a href="#1-js双叹号的作用" class="headerlink" title="1.js双叹号的作用"></a>1.js双叹号的作用</h2><p>按照我的理解，就是为一些基础数据类型做一下Boolean类型的返回，比如<code>（null/undifined/0/&quot;&quot;/NaN）</code>等值，可以返回false</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">var unknow = null; <span class="hljs-regexp">//</span> 这里可以是null<span class="hljs-regexp">/undifined/</span><span class="hljs-number">0</span><span class="hljs-regexp">/&quot;&quot;/</span>NaN任意的值<br>console.log(!!unknow); <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><h2 id="2-js可选链操作符"><a href="#2-js可选链操作符" class="headerlink" title="2.js可选链操作符"></a>2.js可选链操作符</h2><p>这段代码之前老是这么写</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">var</span> ret = res.<span class="hljs-class"><span class="hljs-keyword">data</span> &amp;&amp; res.<span class="hljs-keyword">data</span>.list;</span><br></code></pre></td></tr></table></figure><p>其实是可以这么写的</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">var <span class="hljs-keyword">ret</span> = res.data?<span class="hljs-meta">.list</span><br></code></pre></td></tr></table></figure><p>有点像链式调用，这里需要引申出来这么一个小问题，|| 和 ??的用法</p><h2 id="3-JS中-与-的区别"><a href="#3-JS中-与-的区别" class="headerlink" title="3. JS中??与||的区别"></a>3. JS中??与||的区别</h2><p>相同点：</p><blockquote><p>用法相同，都是前后是值，中间用符号连接。根据前面的值来判断最终返回前面的值还是后面的值。</p></blockquote><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">值<span class="hljs-number">1</span> ?? 值<span class="hljs-number">2</span><br>值<span class="hljs-number">1</span> <span class="hljs-string">|| 值2</span><br></code></pre></td></tr></table></figure><p>不同点:</p><blockquote><p>判断方式不同：</p></blockquote><ul><li>使用 <code>??</code> 时，只有当<code>值1</code>为<code>null</code>或<code>undefined</code>时才返回<code>值2</code>；</li><li>使用 <code>||</code> 时，<code>值1</code>会转换为布尔值判断，为<code>true</code>返回<code>值1</code>，false 返回<code>值2</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> ??<br>undefined ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>null ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-number">0</span> ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br><span class="hljs-string">&quot;&quot;</span> ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br>true ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> true<br>false ?? <span class="hljs-number">2</span><span class="hljs-regexp">//</span> false<br><br><span class="hljs-regexp">//</span> ||<br>undefined || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>null || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-number">0</span> || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-string">&quot;&quot;</span> || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>true || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> true<br>false || <span class="hljs-number">2</span><span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><p>总的来说，<code>??</code>更加适合在不知道变量是否有值时使用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>农民工日记03</title>
    <link href="/2021/10/24/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B003/"/>
    <url>/2021/10/24/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B003/</url>
    
    <content type="html"><![CDATA[<h3 id="1-浏览器重绘和重排的区别？"><a href="#1-浏览器重绘和重排的区别？" class="headerlink" title="1.浏览器重绘和重排的区别？"></a>1.浏览器重绘和重排的区别？</h3><blockquote><p>如何触发重排和重绘？</p></blockquote><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><ul><li>添加、删除、更新DOM节点</li><li>通过display: none隐藏一个DOM节点-触发重排和重绘</li><li>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化</li><li>移动或者给页面中的DOM节点添加动画</li><li>添加一个样式表，调整样式属性</li><li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li></ul><blockquote><p>如何避免重绘或者重排？</p></blockquote><ol><li><p>集中改变样式，不要一条一条地修改 DOM 的样式。</p></li><li><p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p></li><li><p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</p></li><li><p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p></li><li><p>尽量只修改position：absolute或fixed元素，对其他元素影响不大</p></li><li><p>动画开始GPU加速，translate使用3D变化</p></li><li><p>提升为合成层<br>将元素提升为合成层有以下优点：</p></li></ol><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p>提升合成层的最好方式是使用 CSS 的 will-change 属性：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">#<span class="hljs-keyword">target</span> &#123;<br>  will-<span class="hljs-built_in">change</span>: transform;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-手写常见排序"><a href="#2-手写常见排序" class="headerlink" title="2. 手写常见排序"></a>2. 手写常见排序</h3><ul><li>冒泡排序</li></ul><blockquote><p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 <code>length - 1</code> 的位置。</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(list)</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> n = list.length;<br>  <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> [];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-comment">// 注意这里需要 n - i - 1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123;<br>      <span class="hljs-keyword">if</span> (list[j] &gt; list[j + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">var</span> temp = list[j + <span class="hljs-number">1</span>];<br>        list[j + <span class="hljs-number">1</span>] = list[j];<br>        list[j] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>快速排序</li></ul><blockquote><p>快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作</p></blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel">function quickSort(list) &#123;<br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">n</span> = list.length;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">1</span>) return list;<br><br>  <span class="hljs-built_in">var</span> midIndex = Math.floor(<span class="hljs-built_in">n</span> / <span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">var</span> midVal = list[midIndex]; // 取中间的数<br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">left</span> = [];<br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">right</span> = [];<br><br>  for (<span class="hljs-built_in">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">n</span>; i++) &#123;<br>    <span class="hljs-built_in">if</span> (i === midIndex) continue;<br>    <span class="hljs-built_in">if</span> (list[i] &lt; midVal) &#123;<br>      left.push(list[i]);<br>    &#125; else &#123;<br>      right.push(list[i]);<br>    &#125;<br>  &#125;<br><br>  // 递归<br>  return quickSort(<span class="hljs-built_in">left</span>).<span class="hljs-built_in">concat</span>(quickSort(<span class="hljs-built_in">right</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-解决跨域问题"><a href="#3-解决跨域问题" class="headerlink" title="3. 解决跨域问题"></a>3. 解决跨域问题</h3><p>- </p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>农民工日记02</title>
    <link href="/2021/10/13/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B002/"/>
    <url>/2021/10/13/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B002/</url>
    
    <content type="html"><![CDATA[<h3 id="1-深拷贝，浅拷贝"><a href="#1-深拷贝，浅拷贝" class="headerlink" title="1.深拷贝，浅拷贝"></a>1.深拷贝，浅拷贝</h3><ul><li>浅拷贝：重新在堆中创建内存，拷贝前后对象的<code>基本数据类型互不影响</code>，但拷贝前后对象的<code>引用类型</code>因共享同一块内存，会<code>相互影响</code>。</li><li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。</li></ul><p>个人理解：重点是引用类型会相互影响</p><p>基础数据类型：Undefined、Null、Boolean、Number、String、Symbol<br>引用类型：统称为 <code>Object</code> 类型。细分的话，有：<code>Object</code> 类型、<code>Array</code> 类型、<code>Date</code> 类型、<code>RegExp</code> 类型、<code>Function</code> 类型</p><p>我们先来看下面的例子，对比赋值与深/浅拷贝得到的对象修改后对原始对象的影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象赋值</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;浪里行舟&#x27;</span>,<br>    <span class="hljs-attr">arr</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-number">4</span>],<br>&#125;;<br><span class="hljs-keyword">let</span> obj2 = obj1;<br>obj2.name = <span class="hljs-string">&quot;阿浪&quot;</span>;<br>obj2.arr[<span class="hljs-number">1</span>] =[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] ;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj1&#x27;</span>,obj1) <span class="hljs-comment">// obj1 &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj2&#x27;</span>,obj2) <span class="hljs-comment">// obj2 &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="hljs-comment">// 浅拷贝</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;浪里行舟&#x27;</span>,<br>    <span class="hljs-attr">arr</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-number">4</span>],<br>&#125;;<br><span class="hljs-keyword">let</span> obj3=shallowClone(obj1)<br>obj3.name = <span class="hljs-string">&quot;阿浪&quot;</span>;<br>obj3.arr[<span class="hljs-number">1</span>] = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] ; <span class="hljs-comment">// 新旧对象还是共享同一块内存</span><br><span class="hljs-comment">// 这是个浅拷贝的方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowClone</span>(<span class="hljs-params">source</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> target = &#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> source) &#123;<br>        <span class="hljs-keyword">if</span> (source.hasOwnProperty(i)) &#123;<br>            target[i] = source[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj1&#x27;</span>,obj1) <span class="hljs-comment">// obj1 &#123; name: &#x27;浪里行舟&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj3&#x27;</span>,obj3) <span class="hljs-comment">// obj3 &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br><span class="hljs-comment">// 深拷贝</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;浪里行舟&#x27;</span>,<br>    <span class="hljs-attr">arr</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-number">4</span>],<br>&#125;;<br><span class="hljs-keyword">let</span> obj4=deepClone(obj1)<br>obj4.name = <span class="hljs-string">&quot;阿浪&quot;</span>;<br>obj4.arr[<span class="hljs-number">1</span>] = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] ; <span class="hljs-comment">// 新对象跟原对象不共享内存</span><br><span class="hljs-comment">// 这是个深拷贝的方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj; <br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(obj);<br>    <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(obj);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> obj;<br>    <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.constructor();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>      <span class="hljs-keyword">if</span> (obj.hasOwnProperty(key)) &#123;<br>        <span class="hljs-comment">// 实现一个递归拷贝</span><br>        cloneObj[key] = deepClone(obj[key]);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cloneObj;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj1&#x27;</span>,obj1) <span class="hljs-comment">// obj1 &#123; name: &#x27;浪里行舟&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;obj4&#x27;</span>,obj4) <span class="hljs-comment">// obj4 &#123; name: &#x27;阿浪&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span><br></code></pre></td></tr></table></figure><p>浅拷贝实现方式：</p><ul><li>Object. assign();</li><li>函数库lodash的_.clone方法</li><li>Array.prototype.concat();</li><li>Array.prototype.slice();</li></ul><p>深拷贝的实现方式：</p><ul><li>JSON.parse(JSON.stringify()); <strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则</strong></li><li>函数库lodash的_.cloneDeep方法</li></ul><h3 id="2-bind，apply，call的区别"><a href="#2-bind，apply，call的区别" class="headerlink" title="2. bind，apply，call的区别"></a>2. bind，apply，call的区别</h3><p>　　三者都是用于改变函数体内this的指向，但是bind与apply和call的最大的区别是：bind不会立即调用，而是返回一个新函数，称为绑定函数，其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj);<br>&#125;<br><br>test(); <span class="hljs-comment">//false</span><br><br><span class="hljs-keyword">var</span> testObj = test.bind(obj);<br>testObj();  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><pre><code>apply和call都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）；apply和call的调用返回函数执行结果；</code></pre><p>　　如果使用apply或call方法，那么this指向他们的第一个参数，apply的第二个参数是一个参数数组，call的第二个及其以后的参数都是数组里面的元素，就是说要全部列举出来；</p><h3 id="3-从浏览器地址栏输入url到显示页面的步骤"><a href="#3-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="3. 从浏览器地址栏输入url到显示页面的步骤"></a>3. 从浏览器地址栏输入url到显示页面的步骤</h3><p><strong>基础版本</strong></p><ul><li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；（url域名解析，发送请求）</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML</code>、<code>JS</code>、<code>CSS</code>、图象等）；（后端处理请求，浏览器接受文件）</li><li>浏览器对加载到的资源（<code>HTML</code>、<code>JS</code>、<code>CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；（浏览器解析静态资源，建立数据结构）</li><li>载入解析到的资源文件，渲染页面，完成。（载入，渲染）</li></ul><h3 id="4-http和https的区别"><a href="#4-http和https的区别" class="headerlink" title="4. http和https的区别"></a>4. http和https的区别</h3><ul><li>安全性。HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>协议。使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>响应速度。HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>端口。http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>资源占用。HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul><h3 id="5-TCP三次握手"><a href="#5-TCP三次握手" class="headerlink" title="5. TCP三次握手"></a>5. TCP三次握手</h3><p>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认<br>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态<br>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p><h3 id="6-进程、线程、协程"><a href="#6-进程、线程、协程" class="headerlink" title="6. 进程、线程、协程"></a>6. 进程、线程、协程</h3><p><strong>进程</strong>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<code>是操作系统进行资源分配和调度的一个独立单位</code>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p><p><strong>线程</strong>是程序执行中一个单一的顺序控制流程，是<code>程序执行流的最小单元</code>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p><strong>协程</strong>，英文Coroutines，是一种<code>基于线程之上，但又比线程更加轻量级的存在</code>，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p><p><strong>进程和线程的区别与联系</strong></p><p>【区别】：<br>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</p><p>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p><p>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p><p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><p>【联系】：<br>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p><p>处理机分给线程，即真正在处理机上运行的是线程；</p><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步</p><h3 id="7-this的指向（5种情况）"><a href="#7-this的指向（5种情况）" class="headerlink" title="7. this的指向（5种情况）"></a>7. this的指向（5种情况）</h3><ol><li>作为普通函数执行时，<code>this</code>指向<code>window</code>。</li><li>当函数作为对象的方法被调用时，<code>this</code>就会指向<code>该对象</code>。</li><li>构造器调用，<code>this</code>指向<code>返回的这个对象</code>。 new出来的</li><li>箭头函数 箭头函数的<code>this</code>绑定看的是<code>this所在函数定义在哪个对象下</code>，就绑定哪个对象。如果有嵌套的情况，则this绑定到最近的一层对象上。</li><li>基于Function.prototype上的<code>apply 、 call 和 bind</code>调用模式，这三个方法都可以显示的指定调用函数的 this 指向。<code>apply</code>接收参数的是数组，<code>call</code>接受参数列表，<code> bind</code>方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this指向除了使用new时会被改变，其他情况下都不会改变。若为空默认是指向全局对象window。</li></ol><p>// 你不知道的js讲解(感觉这个更好理解一点)</p><ol><li><p>默认绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>run();  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p> 隐式绑定：就是我们常说的，谁调用就绑定谁</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">function <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">this</span>.a);<br>&#125;<br>var obj = &#123;<br>    a: <span class="hljs-number">1</span>,<br>    run<br>&#125;<br>obj.<span class="hljs-built_in">run</span>();  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p>显示绑定：call、apply、bind 实现的绑定我们称为实现显示绑定</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(param) &#123; <br>    console.log( param, this.id ); <br>&#125;<br>var obj = &#123; <br>    id: <span class="hljs-string">&quot;welcome&quot;</span><br>&#125;; <br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach( run, obj );  // <span class="hljs-number">1</span> <span class="hljs-string">&quot;welcome&quot;</span> <span class="hljs-number">2</span> <span class="hljs-string">&quot;welcome&quot;</span> <span class="hljs-number">3</span> <span class="hljs-string">&quot;welcome&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>new绑定</p></li></ol><p>new 就是一个可以调用普通函数的操作符，使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><p>创建（或者说构造）一个全新的对象。=&gt;</p><p>这个新对象会被执行 [[ 原型 ]] 连接。=&gt;</p><p>这个新对象会绑定到函数调用的 this。=&gt;</p><p>如果函数没有返回其他对象，那么 <strong>new 表达式中的函数调用会自动返回这个新对象</strong>。</p><ol start="5"><li>箭头函数下的this</li></ol><p>我们都知道箭头函数没有自己的 this，它的 this 来自于外层作用域，也因为箭头函数没有自己的 this 这一特性，它不能被用作构造函数。<br>箭头函数不使用上面  this  的四种标准规则，函数执行时，它会捕获外层作用域的  this ，一经绑定再也无法修改，并且高于 new 绑定。</p><ol start="6"><li>优先级</li></ol><p>（箭头函数下的this）=&gt; new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>农民工日记01</title>
    <link href="/2021/09/26/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B001/"/>
    <url>/2021/09/26/%E5%86%9C%E6%B0%91%E5%B7%A5%E6%97%A5%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>有些东西不写下来真的是记不住，看几次忘几次，真的佛了。。。</p><h3 id="1-dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点（描述浏览器的渲染过程，DOM树和渲染树的区别）"><a href="#1-dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点（描述浏览器的渲染过程，DOM树和渲染树的区别）" class="headerlink" title="1. dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点（描述浏览器的渲染过程，DOM树和渲染树的区别）"></a>1. dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点（描述浏览器的渲染过程，DOM树和渲染树的区别）</h3><ul><li><p>浏览器的渲染过程：</p><ul><li>解析<code>HTML</code>构建<code>DOM</code>(DOM树)，并行请求<code>css/image/js</code></li><li><code>CSS</code> 文件下载完成，开始构建 <code>CSSOM</code>(<code>CSS</code>树)</li><li><code>CSSOM</code> 构建结束后，和 <code>DOM</code> 一起生成 <code>Render Tree</code>(渲染树)</li><li>布局(<code>Layout</code>)：计算出每个节点在屏幕中的位置</li><li>显示(<code>Painting</code>)：通过显卡把页面画到屏幕上</li></ul></li><li><p><code>DOM</code>树 和 渲染树 的区别：</p><ul><li><code>DOM</code>树与<code>HTML</code>标签一一对应，包括<code>head</code>和隐藏元素</li><li>渲染树不包括<code>head</code>和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的<code>css</code>属性</li></ul></li></ul><h3 id="2-CSS会阻塞dom解析吗？"><a href="#2-CSS会阻塞dom解析吗？" class="headerlink" title="2. CSS会阻塞dom解析吗？"></a>2. CSS会阻塞dom解析吗？</h3><p>先说结论：</p><ul><li>css加载不会阻塞DOM树的解析</li><li>css加载会阻塞DOM树的渲染</li><li>css加载会阻塞后面js语句的执行</li></ul><p>因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:</p><ul><li>使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)</li><li>对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)</li><li>合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)</li><li>减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)</li></ul><p>个人对这种机制的评价<br>其实我觉得，这可能也是浏览器的一种优化机制。因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以我干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染DOM树，这种做法性能方面确实会比较好一点。</p><h3 id="3-浏览器的渲染过程"><a href="#3-浏览器的渲染过程" class="headerlink" title="3. 浏览器的渲染过程"></a>3. 浏览器的渲染过程</h3><p><a href="https://blog.poetries.top/FE-Interview-Questions/docs/excellent.html#_21-1-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">https://blog.poetries.top/FE-Interview-Questions/docs/excellent.html#_21-1-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B</a></p><ol><li>浏览器接收到<strong>HTML</strong>文件并转换为<strong>DOM</strong>树</li><li>将<strong>CSS</strong>文件转换为<strong>CSSOM</strong>树</li><li>生成渲染树</li></ol><h3 id="4-实现一个call（手写）"><a href="#4-实现一个call（手写）" class="headerlink" title="4. 实现一个call（手写）"></a>4. 实现一个call（手写）</h3><p>call做了什么:</p><ul><li>将函数设为对象的属性</li><li>执行&amp;删除这个函数</li><li>指定this到函数并传入给定参数执行函数</li><li>如果不传入参数，默认指向为 window<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs maxima">// 模拟 call bar.mycall(null);<br>//实现一个call方法：<br>// 原理：利用 <span class="hljs-built_in">context</span>.xxx = self obj.xx = func--&gt;obj.xx()<br>Function.prototype.myCall = function(<span class="hljs-built_in">context</span> = window, ...<span class="hljs-built_in">args</span>) &#123;<br>  // this--&gt;func  <span class="hljs-built_in">context</span>--&gt; obj  <span class="hljs-built_in">args</span>--&gt; 传递过来的参数<br><br>  // 在<span class="hljs-built_in">context</span>上加一个唯一值不影响<span class="hljs-built_in">context</span>上的属性<br>  <span class="hljs-built_in">let</span> <span class="hljs-built_in">key</span> = Symbol(&#x27;<span class="hljs-built_in">key</span>&#x27;)<br>  <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>] = this; // <span class="hljs-built_in">context</span>为调用的上下文,this此处为函数，将这个函数作为<span class="hljs-built_in">context</span>的方法<br>  // <span class="hljs-built_in">let</span> <span class="hljs-built_in">args</span> = [...arguments].slice(<span class="hljs-number">1</span>)   //第一个参数为obj所以删除,伪数组转为数组<br>  <br>  <span class="hljs-built_in">let</span> result = <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>](...<span class="hljs-built_in">args</span>);<br>  <span class="hljs-built_in">delete</span> <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>]; // 不删除会导致<span class="hljs-built_in">context</span>属性越来越多<br>  <span class="hljs-built_in">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//用法：f.call(obj,arg1)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(a+b)<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><span class="hljs-keyword">let</span> obj=&#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-number">1</span><br>&#125;<br>f.myCall(obj,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">//否则this指向window</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-实现一个apply（手写）"><a href="#5-实现一个apply（手写）" class="headerlink" title="5. 实现一个apply（手写）"></a>5. 实现一个apply（手写）</h3><blockquote><p>思路: 利用<code>this</code>的上下文特性。</p></blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Function.prototype.myApply = function(<span class="hljs-built_in">context</span> = window, ...<span class="hljs-built_in">args</span>) &#123;<br>  // this--&gt;func  <span class="hljs-built_in">context</span>--&gt; obj  <span class="hljs-built_in">args</span>--&gt; 传递过来的参数<br><br>  // 在<span class="hljs-built_in">context</span>上加一个唯一值不影响<span class="hljs-built_in">context</span>上的属性<br>  <span class="hljs-built_in">let</span> <span class="hljs-built_in">key</span> = Symbol(&#x27;<span class="hljs-built_in">key</span>&#x27;)<br>  <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>] = this; // <span class="hljs-built_in">context</span>为调用的上下文,this此处为函数，将这个函数作为<span class="hljs-built_in">context</span>的方法<br>  // <span class="hljs-built_in">let</span> <span class="hljs-built_in">args</span> = [...arguments].slice(<span class="hljs-number">1</span>)   //第一个参数为obj所以删除,伪数组转为数组<br>  <br>  <span class="hljs-built_in">let</span> result = <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>](<span class="hljs-built_in">args</span>); // 这里和call传参不一样<br>  <span class="hljs-built_in">delete</span> <span class="hljs-built_in">context</span>[<span class="hljs-built_in">key</span>]; // 不删除会导致<span class="hljs-built_in">context</span>属性越来越多<br>  <span class="hljs-built_in">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(a,b)<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><span class="hljs-keyword">let</span> obj=&#123;<br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span><br>&#125;<br>f.myApply(obj,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])  <span class="hljs-comment">//arguments[1]</span><br></code></pre></td></tr></table></figure><h3 id="6-实现bind"><a href="#6-实现bind" class="headerlink" title="6. 实现bind"></a>6. 实现bind</h3><blockquote><p>bind 的实现对比其他两个函数略微地复杂了一点，因为 bind 需要返回一个函数，需要判断一些边界问题，以下是 bind 的实现</p></blockquote><ul><li><code>bind</code> 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 <code>new</code> 的方式，我们先来说直接调用的方式<br>对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来<br>最后来说通过 new 的方式，对于 new 的情况来说，不会被任何方式改变 <code>this</code>，所以对于这种情况我们需要忽略传入的 <code>this</code></li></ul><p><strong>简洁版本</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Function.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(context, <span class="hljs-rest_arg">...outerArgs</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// this-&gt;func context-&gt;obj outerArgs-&gt;[10,20]</span><br>  let self = <span class="hljs-keyword">this</span><br><br>  <span class="hljs-comment">// 返回一个函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-rest_arg">...innerArgs</span>)</span> </span>&#123; <span class="hljs-comment">//返回了一个函数，...innerArgs为实际调用时传入的参数</span><br>    <span class="hljs-comment">// 考虑new的方式</span><br>    <span class="hljs-keyword">if</span>(self <span class="hljs-keyword">instanceof</span> F) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> self(...outerArgs, ...innerArgs)<br>    &#125;<br>    <span class="hljs-comment">// 把func执行，并且改变this即可</span><br>    <span class="hljs-keyword">return</span> self.apply(context, [...outerArgs, ...innerArgs]) <span class="hljs-comment">//返回改变了this的函数，参数合并</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 例子</span><br>document.body.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">func</span>.<span class="hljs-params">bind</span>(<span class="hljs-params">obj</span>, 10, 20)</span>)<br><br><span class="hljs-keyword">function</span> func(params) &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意： bind之后不能再次修改this的执行，bind多次后执行，函数this还是指向第一次bind的对象</p></blockquote><h3 id="7-防抖（手写）"><a href="#7-防抖（手写）" class="headerlink" title="7. 防抖（手写）"></a>7. 防抖（手写）</h3><blockquote><p>防抖函数原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时`</p></blockquote><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p><blockquote><p>eg. 像仿百度搜索，就应该用防抖，当我连续不断输入时，不会发送请求；当我一段时间内不输入了，才会发送一次请求；如果小于这段时间继续输入的话，时间会重新计算，也不会发送请求。</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// func是用户传入需要防抖的函数</span><br><span class="hljs-comment">// wait是等待时间</span><br><span class="hljs-keyword">const</span> debounce = (func, wait = <span class="hljs-number">50</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 缓存一个定时器id</span><br>  let timer = <span class="hljs-number">0</span><br>  <span class="hljs-comment">// 这里返回的函数是每次用户实际调用的防抖函数</span><br>  <span class="hljs-comment">// 如果已经设定过定时器了就清空上一次的定时器</span><br>  <span class="hljs-comment">// 开始一个新的定时器，延迟执行用户传入的方法</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (timer) clearTimeout(timer)<br>    timer = setTimeout(() =&gt; &#123;<br>      func.apply(<span class="hljs-keyword">this</span>, args)<br>    &#125;, wait)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10个好用的的css框架</title>
    <link href="/2021/09/22/10%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84css%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/09/22/10%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84css%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="10个好用的的css框架"><a href="#10个好用的的css框架" class="headerlink" title="10个好用的的css框架"></a>10个好用的的css框架</h1><p>优秀的css框架可以使开发变得更加快速，不再为兼容性苦恼，并且一般都会有合理的布局，作为开发可以减少对UI设计的思考。近期我整理了一些css框架供开发者选择和使用，排名不分先后。</p><h2 id="1-bootstrap"><a href="#1-bootstrap" class="headerlink" title="1.bootstrap"></a>1.bootstrap</h2><p>Bootstrap仍然是最流行的 CSS 框架之一。他们提供了大量的文档、示例和演示，可以帮你快速进行响应式 Web 开发。该框架的当前版本是 Bootstrap 5，相较于V4，做出了一些改变：</p><ul><li>拥有了自己的SVG图标库</li><li>不再支持jquery</li><li>不再支持IE</li><li>增加了css自定义属性</li><li>增强的网格系统</li><li>Forms可被更新</li></ul><p><img src="/img/cssLibraries/bootstrap.png" alt="bootstrap"><br>传送门：<a href="https://getbootstrap.com/">https://getbootstrap.com/</a></p><h2 id="2-tailwind"><a href="#2-tailwind" class="headerlink" title="2.tailwind"></a>2.tailwind</h2><p>Tailwind CSS 是一个功能类优先的 CSS 框架，它集成了诸如<strong>flex</strong>, <strong>pt-4</strong>, <strong>text-center</strong> 和 <strong>rotate-90</strong> 这样的的类，它们能直接在脚本标记语言中组合起来，构建出任何设计。</p><p>主要特性：</p><ul><li>组件化</li><li>体积小，性能高</li><li>响应式</li></ul><p><img src="/img/cssLibraries/tailwindcss.png" alt="tailwind"></p><p>传送门：<a href="https://tailwindcss.com/">https://tailwindcss.com/</a></p><h2 id="3-Foundation"><a href="#3-Foundation" class="headerlink" title="3.Foundation"></a>3.Foundation</h2><p>Foundation 是由产品设计公司 ZURB 制作的自适应前端框架。<br>相比于其他同类型工具，Foundation的移动化方案更加出色。借鉴响应式Web设计的思路和方法，Foundation对内容结构在不同类型设备中的的呈现方式进行了相应的预设。</p><p><img src="/img/cssLibraries/foundation.png" alt="foundation"></p><p>传送门：<a href="https://get.foundation/">https://get.foundation/</a></p><h2 id="4-Skeleton"><a href="#4-Skeleton" class="headerlink" title="4. Skeleton"></a>4. Skeleton</h2><p>如果您正在着手一个较小的项目，或者只是觉得不需要大型框架的所有实用程序，则应该使用 Skeleton。</p><p>在Skeleton css官网中，介绍了三个Skeleton的三大优势：</p><ul><li>Light as a feather at ~400 lines &amp; built with mobile in mind.（超轻量级, 为移动端打造）</li><li>Styles designed to be a starting point, not a UI framework.（样式设计为起点，而非 UI 框架）</li><li>Quick to start with zero compiling or installing necessary.<br>（快速入门，零编译或安装必要）</li></ul><p>根据Skeleton的特点和优势，可以把它的典型应用场景归纳为：</p><ul><li>css学习和demo练习；</li><li>创建小型的响应式手机应用；</li></ul><p><img src="/img/cssLibraries/skeleton.png" alt="skeleton"></p><p>传送门：<a href="http://getskeleton.com/">http://getskeleton.com/</a></p><h2 id="5-Tachyons"><a href="#5-Tachyons" class="headerlink" title="5.Tachyons"></a>5.Tachyons</h2><p>Tachyons具备了当前流行的css框架的优点，无需自己编写大量 CSS。轻量、可定制化和拓展等。Tachyons有极其细化的原子类，只需要在类名中添加属性新的样式即可。不必担心命名冲突，也无需担心样式覆盖，这样可以更能直观的看出样式的具体内容。</p><p><img src="/img/cssLibraries/tachyons.png" alt="tachyons"></p><p>传送门：<a href="https://tachyons.io/">https://tachyons.io/</a></p><h2 id="6-UIkit"><a href="#6-UIkit" class="headerlink" title="6.UIkit"></a>6.UIkit</h2><p>相较于其他通用的css框架，UIkit有一些这些框架没有的组件，比如</p><ul><li>Lightbox（利用模态对话框为图片和视频创建一个别致的灯箱）</li><li>Parallax（依赖于页面滚动条位置的动态 CSS 特性）</li><li>Nestable（创建可以通过拖拽排序的可嵌套式列表）</li><li>Sortable（创建可排序的网格和列表重新来排列元素的顺序）</li><li>…</li></ul><p><img src="/img/cssLibraries/uikit.png" alt="uikit"></p><p>传送门：<a href="https://getuikit.com/">https://getuikit.com/</a></p><h2 id="7-Semantic-UI"><a href="#7-Semantic-UI" class="headerlink" title="7.Semantic UI"></a>7.Semantic UI</h2><p>Semantic意为语义，由于Semantic UI类在命名上清晰易懂，因此开发人员不但节省了学习的时间，也让手头上项目的开发更快、更直观。此外布局的多样性是Semantic UI的另一个优势。通过不同的主题，您可以轻松地为各种项目找到必要的组件。</p><p>Semantic UI存在一些缺点，更新频率相较于其他热门框架较低，并且在某些设备运行响应能力一般。</p><p><img src="/img/cssLibraries/semantic.png" alt="semantic"></p><p>传送门：<a href="https://semantic-ui.com/">https://semantic-ui.com/</a></p><h2 id="8-Bulma"><a href="#8-Bulma" class="headerlink" title="8.Bulma"></a>8.Bulma</h2><p>Bulma 是一个基于 Flexbox 的现代化的 CSS 框架。它提供了随时可用的前端组件，您可以轻松地组合这些组件来构建响应式 Web 界面。</p><p><img src="/img/cssLibraries/bulma.png" alt="bulma"></p><p>和bootstrap相比，两者最大的区别是，bulma是纯css，没有js，bootstrap有JS。这里举个<strong>列布局</strong>的例子：</p><ol><li>添加<code>columns</code>容器</li><li>添加任意数量的<code>column</code>元素</li></ol><p>无论列数是多少，每一列的<strong>宽度</strong>都<strong>相等</strong>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">columns</span>&quot;&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>  &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">column</span>&quot;&gt;<span class="hljs-symbol">5</span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><p>传送门：<a href="https://bulma.io/">https://bulma.io/</a></p><h2 id="9-Picnic"><a href="#9-Picnic" class="headerlink" title="9.Picnic"></a>9.Picnic</h2><p>Picnic是一个轻量级CSS框架，压缩后的大小不到10kb。该框架最大的特点就是具有多个交互式组件，包括栅格、表单、选项卡、工具提示等等，可以帮助开发人员快速创建响应式网站和web应用程序。</p><p>Picnic CSS是一个用<strong>Sass</strong>写的轻量级UI框架，它能更容易的编辑和自定义变量，如颜色和长度。它还有一些不错的纯CSS写的UI组件，如模态窗口和内容滑块。 </p><p><img src="/img/cssLibraries/picnicss.png" alt="picnicss"></p><p>传送门：<a href="https://picnicss.com/">https://picnicss.com/</a></p><h2 id="10-NES-css"><a href="#10-NES-css" class="headerlink" title="10.NES.css"></a>10.NES.css</h2><p>NES.css 模仿了8 位 Nintendo Entertainment System 图形，营造出复古的游戏外观：</p><p>NES.css 只需要 CSS，不依赖任何 JavaScript。作为每个游戏发烧友都会大呼：爱了！</p><p><img src="/img/cssLibraries/NES.png" alt="NES"></p><p>传送门：<a href="https://nostalgic-css.github.io/NES.css/">https://nostalgic-css.github.io/NES.css/</a></p><p>GitHub：<a href="https://github.com/nostalgic-css/NES.css">https://github.com/nostalgic-css/NES.css</a></p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git命令</title>
    <link href="/2021/08/30/git%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/08/30/git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="mac操作，不分先后顺序"><a href="#mac操作，不分先后顺序" class="headerlink" title="mac操作，不分先后顺序"></a>mac操作，不分先后顺序</h3><p>sudo 以管理员身份执行<br>vim 打开编辑器  :wq 保存并退出<br>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。<br>source<br>rm -rf [文件名] 删除文件</p><p>使用新电脑，需要和远程GitHub进行连接，这时候需要ssh进行通信，设置步骤为</p><ol><li>检查ssh keys 是否存在<br>输入下面的命令，如果有文件id_rsa.pub 或 id_dsa.pub，则直接进入步骤3将SSH key添加到GitHub中，否则进入第二步生成SSH key<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> -al ~<span class="hljs-string">/.ssh</span><br><span class="hljs-comment"># Lists the files in your .ssh directory, if they exist</span><br></code></pre></td></tr></table></figure></li><li>生成新的ssh key<br>在命令行中输入<strong>ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#111;&#117;&#x72;&#x5f;&#x65;&#109;&#97;&#105;&#x6c;&#x40;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#x79;&#111;&#117;&#x72;&#x5f;&#x65;&#109;&#97;&#105;&#x6c;&#x40;&#101;&#120;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a>“</strong></li><li>将ssh key添加到GitHub中<br>用自己喜欢的文本编辑器打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到GitHub的Add SSH key页面即可</li></ol><p>不同的操作系统，均有一些命令，直接将SSH key从文件拷贝到粘贴板中，如下：<br>mac: </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">pbcopy &lt; ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub<br><span class="hljs-comment"># Copies the contents of the id_rsa.pub file to your clipboard</span><br></code></pre></td></tr></table></figure><p>可以使用vim编辑</p><p>vim /etc/hosts<br>绑定域名</p><p>nvm环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NVM_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.nvm&quot;</span><br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span>  <span class="hljs-comment"># This loads nvm</span><br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/bash_completion&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/bash_completion&quot;</span>  <span class="hljs-comment"># This loads nvm bash_completion</span><br><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;ls -alF&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总结一下自己对promise的理解</title>
    <link href="/2021/08/23/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E5%AF%B9promise%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/08/23/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E5%AF%B9promise%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>学习本身是比较枯燥的，个人认为最大的外因是当下没有需求去获取知识。举个例子，比如打游戏被对面杀爆了，被站在泉水门口堵着杀😥，心态崩了，就想回过头来练好杀崩我的这个英雄，抑或看上了今天晚上游泳时候在隔壁泳道宛若游龙的妹子，不知道如何搭讪便准备好好练习游泳，幻想着有机会去和妹子说句话~(然而当我练成了，再也没见过这个妹子了。。。)</p><p>当我想去学一个东西的时候，遇到的第一个困境就是不知道这个东西有什么用，学了之后会给自己带来多少提升，硬着头皮打开文档，一看好长，就瞬间不想学了。后面遇到这个东西的频率越来越高，而不得不去了解这个东西的时候，这个潜在关系就结合起来了，因为<strong>需要</strong>所以<strong>重要</strong>。</p><h2 id="promise解决了什么问题"><a href="#promise解决了什么问题" class="headerlink" title="promise解决了什么问题"></a>promise解决了什么问题</h2><p>在传统的异步编程中，如果异步之间存在依赖关系，就需要通过层层嵌套回调的方式满足这种依赖，如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱”，而 Promise <strong>将嵌套调用改为链式调用</strong>，增加了可阅读性和可维护性。也就是说，Promise 解决的是<strong>异步编码风格</strong>的问题。</p><h2 id="promise和async-await"><a href="#promise和async-await" class="headerlink" title="promise和async|await"></a>promise和async|await</h2><p>我前端调用接口的时候，往往都是使用的都是promise对象。查看调用接口的类型标注，看到是promise对象，而我把async去掉，当前函数的类型就不是promise了，async和promise肯定是有关系的。查了一下相关资料，get</p><p>相同点：</p><ul><li>都是解决异步流程问题</li></ul><p>不同点：</p><ul><li>Promise是es6里的，async是es7。</li><li>Promise链式操作，自己catch异常。async则要在函数内catch。</li><li>Promise有很多并行神器，比如Promise.all\Promise.allSettled\Promise.race等。这些是async没法搞定的</li><li>Promise是显式的异步，而Async/await 让你的代码看起来是同步的，你依然需要注意异步。</li><li>Promise即使不支持es6，仍然可以用promise的库或polyfill，而async就很难做。</li></ul><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>和promise、async、await相比，我基本上很少用他，理解不是很深，下面只写一些基本介绍。</p><p>Generator 是ES6引入的新语法，Generator是一个可以暂停和继续执行的函数。</p><p>简单的用法，可以当做一个Iterator来用，进行一些遍历操作。复杂一些的用法，他可以在内部保存一些状态，成为一个状态机。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">Generator</span> 基本语法包含两部分：函数名前要加一个星号；函数内部用 <span class="hljs-keyword">yield</span> 关键字返回值。<br></code></pre></td></tr></table></figure><ul><li><p>yield，表达式本身没有返回值，或者说总是返回undefined。</p></li><li><p>next，方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>&#123;<br><br>    <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span> * (<span class="hljs-keyword">yield</span> (x + <span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">var</span> z = <span class="hljs-keyword">yield</span> (y / <span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">return</span> (x + y + z);<br><br>&#125;<br><br><span class="hljs-keyword">var</span> b = foo(<span class="hljs-number">5</span>); <br><br>b.next() <span class="hljs-comment">// &#123; value:6, done:false &#125;</span><br><br>b.next(<span class="hljs-number">12</span>) <span class="hljs-comment">// &#123; value:8, done:false &#125; </span><br><br>b.next(<span class="hljs-number">13</span>) <span class="hljs-comment">// &#123; value:42, done:true &#125;</span><br><br></code></pre></td></tr></table></figure><h2 id="然后再说一下自己对promise的基本理解"><a href="#然后再说一下自己对promise的基本理解" class="headerlink" title="然后再说一下自己对promise的基本理解"></a>然后再说一下自己对promise的基本理解</h2><ul><li><p>依照<strong>Promise/A+<strong>的定义，</strong>Promise</strong>有四种状态：</p><p>  <strong>pending</strong>: 初始状态, 非 <strong>fulfilled</strong> 或 <strong>rejected</strong>.</p><p>  <strong>fulfilled</strong>: 成功的操作.</p><p>  <strong>rejected</strong>: 失败的操作.</p><p>  <strong>settled</strong>: Promise已被<strong>fulfilled</strong>或<strong>rejected</strong>，且不是<strong>pending</strong></p><p>补充一下，promise的A+定义：</p><ol><li><p>一个promise的当前状态只能是pending、fulfilled和rejected三种之一。状态改变只能是pending到fulfilled或者pending到rejected。状态改变不可逆。</p></li><li><p>promise的then方法接收两个可选参数，表示该promise状态改变时的回调(promise.then(onFulfilled, onRejected))。then方法返回一个promise，then 方法可以被同一个 promise 调用多次。</p></li></ol></li></ul><ul><li><p>另外， fulfilled与 rejected一起合称 settled</p></li><li><p>Promise 对象用来进行延迟(deferred) 和异步(asynchronous) 计算</p></li></ul><p><strong>promise只是用来解决异步计算的一种方法，和调用接口没有直接的必然关系，应该反过来说，调用接口需要使用promise来解决异步的问题，可能接口调用封装了多层，自己没有查到最底层的源码。</strong></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>光说不练假把式，直接上题。</p><h3 id="1-Promise的几道基础题"><a href="#1-Promise的几道基础题" class="headerlink" title="1. Promise的几道基础题"></a>1. Promise的几道基础题</h3><h4 id="1-1-题目一"><a href="#1-1-题目一" class="headerlink" title="1.1 题目一"></a>1.1 题目一</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>, promise1);<br></code></pre></td></tr></table></figure><ul><li>从上至下，先遇到new Promise，执行该构造函数中的代码promise1</li><li>然后执行同步代码1，此时promise1没有被resolve或者reject，因此状态还是pending</li></ul><h4 id="1-2-题目二"><a href="#1-2-题目二" class="headerlink" title="1.2 题目二"></a>1.2 题目二</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><ul><li>从上至下，先遇到new Promise，执行其中的同步代码1</li><li>再遇到resolve(‘success’)， 将promise的状态改为了resolved并且将值保存下来</li><li>继续执行同步代码2</li><li>跳出promise，往下执行，碰到promise.then这个微任务，将其加入微任务队列</li><li>执行同步代码4</li><li>本轮宏任务全部执行完毕，检查微任务队列，发现promise.then这个微任务且状态为resolved，执行它。</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="1-3-题目三"><a href="#1-3-题目三" class="headerlink" title="1.3 题目三"></a>1.3 题目三</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><ul><li><p>和题目二相似，只不过在promise中并没有resolve或者reject</p></li><li><p>因此promise.then并不会执行，它只有在被改变了状态之后才会执行。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h4 id="1-4-题目四"><a href="#1-4-题目四" class="headerlink" title="1.4 题目四"></a>1.4 题目四</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve(<span class="hljs-string">&#x27;resolve1&#x27;</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> promise2 = promise1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>, promise1);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>, promise2);<br></code></pre></td></tr></table></figure></li><li><p>从上至下，先遇到new Promise，执行该构造函数中的代码promise1</p></li><li><p>碰到resolve函数, 将promise1的状态改变为resolved, 并将结果保存下来</p></li><li><p>碰到promise1.then这个微任务，将它放入微任务队列</p></li><li><p>promise2是一个新的状态为pending的Promise`</p></li><li><p>执行同步代码1， 同时打印出promise1的状态是resolved</p></li><li><p>执行同步代码2，同时打印出promise2的状态是pending</p></li><li><p>宏任务执行完毕，查找微任务队列，发现promise1.then这个微任务且状态为resolved，执行它。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-string">&#x27;promise1&#x27;</span><br><span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="hljs-string">&#x27;resolve1&#x27;</span>&#125;<br><span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-built_in">Promise</span>&#123;&lt;pending&gt;&#125;<br><span class="hljs-string">&#x27;resolve1&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="1-5-题目五"><a href="#1-5-题目五" class="headerlink" title="1.5 题目五"></a>1.5 题目五</h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> = <span class="hljs-params">()</span> =&gt; <span class="hljs-params">(<span class="hljs-keyword">new</span> Promise<span class="hljs-params">(<span class="hljs-params">(resolve, reject)</span> =&gt; &#123;</span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-function">  console.log<span class="hljs-params">(<span class="hljs-number">1</span>)</span>;</span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-function">  resolve<span class="hljs-params">(<span class="hljs-string">&#x27;success&#x27;</span>)</span></span></span></span><br><span class="hljs-params"><span class="hljs-params"><span class="hljs-function">&#125;)</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">()</span>.<span class="hljs-title">then</span><span class="hljs-params">(res =&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  console.log<span class="hljs-params">(res)</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span><br><span class="hljs-function"><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-string">&#x27;start&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>请仔细看看哦，fn函数它是直接返回了一个new Promise的，而且fn函数的调用是在start之前，所以它里面的内容应该会先执行。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-number">1</span><br><span class="hljs-symbol">&#x27;start</span>&#x27;<br><span class="hljs-symbol">&#x27;success</span>&#x27;<br></code></pre></td></tr></table></figure><h4 id="1-6-题目六"><a href="#1-6-题目六" class="headerlink" title="1.6 题目六"></a>1.6 题目六</h4><p>如果把fn的调用放到start之后呢？</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const fn = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    resolve(<span class="hljs-string">&quot;success&quot;</span>);<br>  &#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;start&quot;</span>);<br>fn().<span class="hljs-keyword">then</span>(res =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(res);<br>&#125;);<br></code></pre></td></tr></table></figure><p>现在start就在1之前打印出来了，因为fn函数是之后执行的。</p><p>  注意⚠️：之前我们很容易就以为看到new Promise()就执行它的第一个参数函数了，其实这是不对的，就像这两道题中，我们得注意它是不是被包裹在函数当中，如果是的话，只有在函数调用的时候才会执行。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;start&quot;</span><br><span class="hljs-number">1</span><br><span class="hljs-string">&quot;success&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p>未完待续。。。</p><p>手写：</p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React事件通信</title>
    <link href="/2021/07/30/React%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/07/30/React%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>React组件之间的通信一般分为下面几种情况：</p><ul><li>父子组件之间的通信</li><li>非嵌套组件之间的通信</li></ul><h2 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h2><p>这是最简单也是最常用的一种通信方式：父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。下面贴两段代码:</p><p>父组件 FatherComp.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> Son <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./SonComp&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FatherComp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Son</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;我就是高阶领主&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>子组件 SonComp.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> Son = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;props.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Son;<br></code></pre></td></tr></table></figure><p>这个也没啥好说的，最简单的透传，下面主要介绍非嵌套的组件之间的通信。</p><h2 id="非嵌套组件之间的通信"><a href="#非嵌套组件之间的通信" class="headerlink" title="非嵌套组件之间的通信"></a>非嵌套组件之间的通信</h2><p>简单来说就是组件之间没有什么关联，需要通信就需要有个媒介，这里我们采用自定义事件的方式来进行通信：<br>首先需要安装一个event包</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install events <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>新建一个 event.js，引入 events 包，并向外提供一个事件对象，供通信时使用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> &#123; EventEmitter &#125; from <span class="hljs-string">&quot;events&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title">EventEmitter</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>App.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><br><span class="hljs-keyword">import</span> Comp1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Comp1&quot;</span>;<br><span class="hljs-keyword">import</span> Comp2 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Comp2&quot;</span>;<br><span class="hljs-keyword">import</span> FatherComp <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./FatherComp&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">FatherComp</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Comp1</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Comp2</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>Comp1.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./event&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Comp1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [msg, setMsg] = useState(<span class="hljs-literal">null</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 声明一个自定义事件</span><br>    <span class="hljs-comment">// 在组件装载完成以后</span><br>    <span class="hljs-built_in">this</span>.eventEmitter = emitter.addListener(<span class="hljs-string">&quot;clickMe&quot;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>      setMsg(msg);<br>    &#125;);<br>    <span class="hljs-comment">// 组件销毁前移除事件监听</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      emitter.removeListener(<span class="hljs-built_in">this</span>.eventEmitter);<br>    &#125;;<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      &#123;msg&#125;</span><br><span class="xml">      组件1</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>Comp2.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./event&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Comp2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> cb = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 触发自定义事件</span><br>      emitter.emit(<span class="hljs-string">&quot;clickMe&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      组件2<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;cb()&#125;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们写一个简单的事件demo来深入了解一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eventPool = &#123;<br>  <span class="hljs-attr">map</span>: &#123;&#125;,<br>  <span class="hljs-comment">// 事件订阅</span><br>  <span class="hljs-attr">on</span>: <span class="hljs-function">(<span class="hljs-params">name, cb</span>) =&gt;</span> &#123;<br>    eventPool.map[name] = cb;<br>  &#125;,<br>  <span class="hljs-comment">// 事件发射</span><br>  <span class="hljs-attr">emit</span>: <span class="hljs-function">(<span class="hljs-params">name, ...args</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> cb = eventPool.map[name];<br>    cb &amp;&amp; cb(...args);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// xxx为事件名，有两个参数</span><br>eventPool.on(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-function">(<span class="hljs-params">p1, p2</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(p1, p2));<br><span class="hljs-comment">// 发射完直接打印了这两个参数</span><br>eventPool.emit(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自定义事件在组件之间没有直接联系的情况下使用还是很方便的，总之就是香~<br><a href="https://codesandbox.io/s/comp-interaction-demo-8ov47">这里</a>是本篇文章涉及的代码</p>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 简介，安装，部署</title>
    <link href="/2021/07/30/hexo%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/07/30/hexo%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>hexo是使用node.js开发的一个快速、简洁、高效、开源的静态博客生成器，使用了<a href="https://www.zybuluo.com/mdeditor">MarkDown</a>解析文章。我们可以用hexo在本地起好服务，托管到github就能通过github域名访问(免费，省事)，当然也可以使用自定义的域名解析(花钱，高大上)。</p><p>本文可能对初学计算机的童鞋们不太友好，这里省去了node.js和git的安装及配置，包括设置Git用户信息，生成SSH key公钥，这里不再赘述，可以自行百度~</p><h3 id="git仓库配置"><a href="#git仓库配置" class="headerlink" title="git仓库配置"></a>git仓库配置</h3><p>我采用的是hexo + githubPages搭建，首先需要<strong>在GitHub上创建Github Pages服务</strong>，具体步骤如下图：<br><img src="/img/hexo-deploy.png" alt="hexo-deploy"><br>点击之后仓库名一定要填 用户名.github.io 的格式(形如zhangzheyi1.github.io)，不要填 用户名 的格式(形如zhangzheyi1)，这里踩了好几次坑了，浪费了不少事件，因为现在我已经有这个仓库了，这个报错可以忽略掉，下面的readme记得点上❤，最后一步点创建<br><img src="/img/hexo-deploy2.png" alt="hexo-deploy2"></p><h3 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli <span class="hljs-comment">#全局安装hexo脚手架</span><br></code></pre></td></tr></table></figure><h3 id="初始化创建博客"><a href="#初始化创建博客" class="headerlink" title="初始化创建博客"></a>初始化创建博客</h3><h3 id="1-创建站点根目录"><a href="#1-创建站点根目录" class="headerlink" title="1.创建站点根目录"></a>1.创建站点根目录</h3><p>首先需要初创建一个博客文件夹，注意这个<strong>文件夹的名字</strong>最好要和你刚才创建的GitHubPages的地址一致也就是<strong>your_github_name.github.io</strong>(形如zhangzheyi1.github.io)。这个文件夹以后也统称为站点根目录。</p><h3 id="2-初始化站点根目录"><a href="#2-初始化站点根目录" class="headerlink" title="2.初始化站点根目录"></a>2.初始化站点根目录</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> mkdir &lt;folder&gt;  <span class="hljs-comment">#创建站点根目录，形如(mkdir zhangzheyi1.github.io)</span><br><span class="hljs-variable">$</span> hexo init &lt;folder&gt;  <span class="hljs-comment">#使用Hexo初始化站点根目录(hexo init zhangzheyi1.github.io)</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;  <span class="hljs-comment">#进入到站点根目录(cd zhangzheyi1.github.io)</span><br><span class="hljs-variable">$</span> npm install  <span class="hljs-comment">#安装npm所依赖的文件</span><br></code></pre></td></tr></table></figure><p>等他安装好，在输入两条就能访问本地的博客了</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span> # 生成博客<br>$ hexo server # 本地预览<br></code></pre></td></tr></table></figure><p>默认端口是4000，直接浏览器键入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以访问了，现在是默认的主题</p><p><img src="/img/hexo-deploy3.png" alt="hexo-deploy3"></p><h3 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h3><p>现在我们只能在本地预览，想在gitPage上预览还需要进行一些配置，找到根目录下的_confi.yml文件，拉到最下面我们看到的是以下code</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>deploy就是部署的意思，这里部署的话需要填下信息，修改为以下代码就可以</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:zhangzheyi1/zhangzheyi1.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>repo就是仓库地址，这儿用的是SSH，找到刚才创建的仓库，把这个地址复制下来粘到repo里就可以了</p><p><img src="/img/hexo-deploy4.png" alt="hexo-deploy4"></p><p>安装以下插件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span> hexo-deployer-git —save<br></code></pre></td></tr></table></figure><p>执行以下命令发布本地博客到远程仓库：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>可能到这步登陆<strong>your_github_name.github.io</strong>，形如zhangzheyi1.github.io，有些同学还是没办法看到自己的博客，就是因为github的配置有点恶心人，当时我也在这儿不知道怎么搞，是因为默认的分支是main，而不是master，需要点击仓库的settings =&gt; pages 然后修改一下默认的分支就可以<br><img src="/img/hexo-deploy5.png" alt="hexo-deploy5"></p><p>到这步基本上就ok了，网上发的好多博客都是很久以前写的，github的版本和hexo的配置文件都不一样，按照本篇文章应该可以完成，现在的博客只是一个默认主题，xdm想换主题的话可以在网上搜一下主题，本博客用的是Fluid主题，第一次发文，确实挺耗时间的，希望自己以后能坚持下去~</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
